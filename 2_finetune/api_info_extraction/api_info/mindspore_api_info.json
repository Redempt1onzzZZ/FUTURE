[
  {
    "name": "mindspore.ops.numel",
    "signature": "mindspore.ops.numel(input)",
    "description": "Returns a Scalar of type int that represents the total number of elements in the Tensor.",
    "parameters": [
      "input (Tensor) – Input Tensor."
    ],
    "returns": "int. A scalar representing the total of elements in the Tensor.",
    "examples": ">>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> input_x = Tensor(np.array([[2, 2], [2, 2]]), mindspore.float32)\n>>> print(ops.numel(input_x))\n4\n"
  },
  {
    "name": "mindspore.ops.zeros",
    "signature": "mindspore.ops.zeros(size, dtype=None)",
    "description": "Creates a tensor filled with 0 with shape described by shape and fills it with value 0 in type of dtype.",
    "parameters": [
      "size (Union[tuple[int], int, Tensor]) – The specified shape of output tensor. Only positive integer or tuple or Tensor containing positive integers are allowed. If it is a Tensor, it must be a 0-D or 1-D Tensor with int32 or int64 dtypes.",
      "dtype (mindspore.dtype, optional) – The specified type of output tensor. If dtype is None , mindspore.float32 will be used. Default: None ."
    ],
    "returns": "Tensor, has the same dtype and size as input.",
    "examples": "mindspore.dtype\nNone\nNone\n>>> import mindspore\n>>> from mindspore import ops\n>>> output = ops.zeros((2, 2), mindspore.float32)\n>>> print(output)\n[[0. 0.]\n [0. 0.]]\n"
  },
  {
    "name": "mindspore.ops.ones",
    "signature": "mindspore.ops.ones(shape, dtype=None)",
    "description": "Creates a tensor filled with value ones.",
    "parameters": [
      "shape (Union[tuple[int], int, Tensor]) – The specified shape of output tensor. Only positive integer or tuple or Tensor containing positive integers are allowed. If it is a Tensor, it must be a 0-D or 1-D Tensor with int32 or int64 dtypes.",
      "dtype (mindspore.dtype) – The specified type of output tensor. If dtype is None , mindspore.float32 will be used. Default: None ."
    ],
    "returns": "Tensor, has the same type and shape as input shape value.",
    "examples": "mindspore.dtype\nNone\nNone\n>>> import mindspore\n>>> from mindspore import ops\n>>> output = ops.ones((2, 2), mindspore.float32)\n>>> print(output)\n[[1. 1.]\n [1. 1.]]\n"
  },
  {
    "name": "mindspore.ops.ones_like",
    "signature": "mindspore.ops.ones_like(input, *, dtype=None)",
    "description": "Returns a Tensor with a value of 1 and its shape is the same as the input.",
    "parameters": [
      "input (Tensor) – Tensor of any dimension."
    ],
    "returns": "Tensor, has the same shape as input but filled with ones.",
    "examples": "mindspore.dtype\nNone\nNone\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> x = Tensor(np.array([[0, 1], [2, 1]]).astype(np.int32))\n>>> output = ops.ones_like(x)\n>>> print(output)\n[[1 1]\n [1 1]]\n"
  },
  {
    "name": "mindspore.ops.arange",
    "signature": "mindspore.ops.arange(start=0, end=None, step=1, *, dtype=None)",
    "description": "Creates a sequence of numbers that begins at start and extends by increments of step up to but not including end.",
    "parameters": [
      "start (Union[float, int, Tensor], optional) – The start of the interval. If Tensor, the shape must be \\(()\\) . Default: 0 .",
      "end (Union[float, int, Tensor], optional) – The end of the interval, exclusive. If Tensor, the shape must be \\(()\\). Default: None . If None , it defaults to the value of start, and 0 is used as the starting value.",
      "step (Union[float, int, Tensor], optional) – Number that increments start. If Tensor, the shape must be \\(()\\). Default: 1 ."
    ],
    "returns": "A 1-D Tensor, with the same type as the inputs.",
    "examples": "0\nNone\nNone\n1\nNone\nNone\n>>> import mindspore as ms\n>>> from mindspore import Tensor, ops\n>>> output = ops.arange(1, 6)\n>>> print(output)\n[1 2 3 4 5]\n>>> print(output.dtype)\nInt64\n>>> output = ops.arange(0, 3, 1.2)\n>>> print(output)\n[0.  1.2 2.4]\n>>> print(output.dtype)\nFloat32\n>>> output = ops.arange(7, 1, -2)\n>>> print(output)\n[7 5 3]\n>>> print(output.dtype)\nInt64\n>>> output = ops.arange(ms.Tensor(12.0, dtype=ms.float64), 2, ms.Tensor(-1.0, dtype=ms.float32))\n>>> print(output)\n[12. 11. 10.  9.  8.  7.  6.  5.  4.  3.]\n>>> print(output.dtype)\nFloat64\n"
  },
  {
    "name": "mindspore.ops.linspace",
    "signature": "mindspore.ops.linspace(start, end, steps)",
    "description": "Returns a Tensor whose value is steps evenly spaced in the interval start and end (including start and end), and the length of the output Tensor is steps.",
    "parameters": [
      "start (Union[Tensor, int, float]) – Start value of interval. The tensor data type must be float32 or float64 and with shape of 0-D.",
      "end (Union[Tensor, int, float]) – Last value of interval. The tensor data type must be float32 or float64 and with shape of 0-D.",
      "steps (Union[Tensor, int]) – Number of ticks in the interval, inclusive of start and end. Must be positive int number or 0D int32/int64 Tensor."
    ],
    "returns": "Tensor, has the same dtype as start, and the shape of \\((steps)\\).",
    "examples": ">>> import mindspore\n>>> from mindspore import Tensor, ops\n>>> start = Tensor(1, mindspore.float32)\n>>> end = Tensor(10, mindspore.float32)\n>>> steps = 5\n>>> output = ops.linspace(start, end, steps)\n>>> print(output)\n[ 1.    3.25  5.5   7.75 10.  ]\n"
  },
  {
    "name": "mindspore.ops.eye",
    "signature": "mindspore.ops.eye(n, m=None, dtype=None)",
    "description": "Creates a tensor with ones on the diagonal and zeros in the rest.",
    "parameters": [
      "n (int) – The number of rows of returned tensor. Constant value only.",
      "m (int) – The number of columns of returned tensor. Constant value only. Default: None , if None , the number of columns is as the same as n.",
      "dtype (mindspore.dtype) – MindSpore’s dtype, the data type of the returned tensor. The data type can be bool or Number. Default: None , the data type of the returned tensor is mindspore.float32."
    ],
    "returns": "Tensor, a tensor with ones on the diagonal and the rest of elements are zero. The shape of output depends on the user’s Inputs n and m. And the data type depends on Inputs dtype.",
    "examples": "None\nNone\nNone\n>>> import mindspore\n>>> from mindspore import ops\n>>> output = ops.eye(2, 2, mindspore.int32)\n>>> print(output)\n[[1 0]\n [0 1]]\n>>> print(output.dtype)\nInt32\n>>> output = ops.eye(1, 2, mindspore.float64)\n>>> print(output)\n[[1. 0.]]\n>>> print(output.dtype)\nFloat64\n>>> output = ops.eye(2, dtype=mindspore.int32)\n>>> print(output)\n[[1 0]\n [0 1]]\n>>> print(output.dtype)\nInt32\n>>> output = ops.eye(2)\n>>> print(output)\n[[1. 0.]\n [0. 1.]]\n>>> print(output.dtype)\nFloat32\n"
  },
  {
    "name": "mindspore.ops.full",
    "signature": "mindspore.ops.full(size, fill_value, *, dtype=None)",
    "description": "Create a Tensor of the specified shape and fill it with the specified value.",
    "parameters": [
      "size (Union(tuple[int], list[int])) – The specified shape of output tensor.",
      "fill_value (number.Number) – Value to fill the returned tensor. Complex numbers are not supported for now."
    ],
    "returns": "Tensor.",
    "examples": "mindspore.dtype\nNone\n>>> from mindspore import ops\n>>> output = ops.full((2, 2), 1)\n>>> print(output)\n[[1. 1.]\n [1. 1.]]\n>>> output = ops.full((3, 3), 0)\n>>> print(output)\n[[0. 0. 0.]\n [0. 0. 0.]\n [0. 0. 0.]]\n"
  },
  {
    "name": "mindspore.ops.full_like",
    "signature": "mindspore.ops.full_like(input, fill_value, *, dtype=None)",
    "description": "Return a Tensor of the same shape as input and filled with fill_value.",
    "parameters": [
      "input (Tensor) – input Tensor and the output Tensor have the same shape as input.",
      "fill_value (Number) – Value to fill the returned Tensor. Complex numbers are not supported for now."
    ],
    "returns": "Tensor.",
    "examples": "mindspore.dtype\nNone\n>>> import mindspore\n>>> from mindspore import Tensor, ops\n>>> input = Tensor([[0, 1], [2, 1]], dtype=mindspore.int32)\n>>> output = ops.full_like(input, 1)\n>>> print(output)\n[[1. 1.]\n [1. 1.]]\n>>> input = Tensor([[0, 1, 1], [2, 1, 2], [1, 3, 4]], dtype=mindspore.int32)\n>>> output = ops.full_like(input, 0)\n>>> print(output)\n[[0. 0. 0.]\n [0. 0. 0.]\n [0. 0. 0.]]\n"
  },
  {
    "name": "mindspore.ops.logspace",
    "signature": "mindspore.ops.logspace(start, end, steps, base=10, *, dtype=mstype.float32)",
    "description": "Returns a 1-D Tensor with size steps whose value is from \\(base^{start}\\) to \\(base^{end}\\), and use base as the base number.",
    "parameters": [
      "start (Union[float, Tensor]) – Start value of interval.",
      "end (Union[float, Tensor]) – End value of interval.",
      "steps (int) – The steps must be a non-negative integer.",
      "base (int, optional) – The base must be a non-negative integer. Default: 10 .",
      "dtype (mindspore.dtype, optional) – The dtype of output. Default: mstype.float32 ."
    ],
    "returns": "Tensor has the shape as \\((step, )\\). Its datatype is set by the attr ‘dtype’.",
    "examples": "10\nmstype.float32\n>>> import mindspore\n>>> from mindspore import Tensor, ops\n>>> start = Tensor(1, mindspore.float32)\n>>> end = Tensor(10, mindspore.float32)\n>>> output = ops.logspace(start, end, steps = 10, base = 10, dtype=mindspore.float32)\n>>> print(output)\n[1.e+01 1.e+02 1.e+03 1.e+04 1.e+05 1.e+06 1.e+07 1.e+08 1.e+09 1.e+10]\n"
  },
  {
    "name": "mindspore.ops.argwhere",
    "signature": "mindspore.ops.argwhere(input)",
    "description": "Return a Tensor of the positions of all non-zero values.",
    "parameters": [
      "input (Tensor) – The input tensor. The data type is Number or Bool."
    ],
    "returns": "Tensor, a 2-D Tensor whose data type is int64, containing the positions of all non-zero values of the input.",
    "examples": ">>> import mindspore\n>>> from mindspore import Tensor, ops\n>>> import numpy as np\n>>> x = Tensor(np.array([[[1,  0], [-5, 0]]]), mindspore.int32)\n>>> output = ops.argwhere(x)\n>>> print(output)\n[[0 0 0]\n [0 1 0]]\n"
  },
  {
    "name": "mindspore.ops.cat",
    "signature": "mindspore.ops.cat(tensors, axis=0)",
    "description": "Connect input tensors along with the given axis.",
    "parameters": [
      "tensors (Union[tuple, list]) – A tuple or a list of input tensors. Suppose there are two tensors in this tuple or list, namely t1 and t2. To perform concat in the axis 0 direction, except for the \\(0\\)-th axis, all other dimensions should be equal, that is, \\(t1.shape[1] = t2.shape[1], t1.shape[2] = t2.shape[2], ..., t1.shape[R-1] = t2.shape[R-1]\\), where \\(R\\) represents the rank of tensor.",
      "axis (int) – The specified axis, whose value is in range \\([-R, R)\\). Default: 0 ."
    ],
    "returns": "Tensor, the shape is \\((x_1, x_2, ..., \\sum_{i=1}^Nx_{mi}, ..., x_R)\\). The data type is the same with tensors.",
    "examples": "0\n>>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> input_x1 = Tensor(np.array([[0, 1], [2, 1]]).astype(np.float32))\n>>> input_x2 = Tensor(np.array([[0, 1], [2, 1]]).astype(np.float32))\n>>> output = ops.cat((input_x1, input_x2))\n>>> print(output)\n[[0. 1.]\n [2. 1.]\n [0. 1.]\n [2. 1.]]\n>>> output = ops.cat((input_x1, input_x2), 1)\n>>> print(output)\n[[0. 1. 0. 1.]\n [2. 1. 2. 1.]]\n"
  },
  {
    "name": "mindspore.ops.column_stack",
    "signature": "mindspore.ops.column_stack(tensors)",
    "description": "Stacks 1-D tensors as columns into a 2-D tensor. Tensors of other dimension are stacked as-is, like mindspore.ops.hstack().",
    "parameters": [
      "tensors (Union[tuple[Tensor], list[Tensor]]) – A sequence of tensors. All of them must have the same shape except the axis to be concatenated."
    ],
    "returns": "2-D Tensor, formed by stacking the given tensors.",
    "examples": "mindspore.ops.hstack()\n>>> from mindspore import Tensor, ops\n>>> x1 = Tensor([1, 1, 1])\n>>> x2 = Tensor([2, 2, 2])\n>>> output = ops.column_stack((x1, x2))\n>>> print(output)\n[[1 2]\n [1 2]\n [1 2]]\n"
  },
  {
    "name": "mindspore.ops.concat",
    "signature": "mindspore.ops.concat(tensors, axis=0)",
    "description": "Alias for mindspore.ops.cat().",
    "parameters": [],
    "returns": "",
    "examples": ""
  },
  {
    "name": "mindspore.ops.chunk",
    "signature": "mindspore.ops.chunk(input, chunks, axis=0)",
    "description": "Cut the input Tensor into chunks sub-tensors along the specified axis.",
    "parameters": [
      "input (Tensor) – A Tensor to be cut.",
      "chunks (int) – Number of sub-tensors to cut.",
      "axis (int, optional) – Specify the dimensions that you want to split. Default: 0 ."
    ],
    "returns": "A tuple of sub-tensors.",
    "examples": "0\n>>> import numpy as np\n>>> from mindspore import ops, Tensor\n>>> input_x = np.arange(9).astype(\"float32\")\n>>> output = ops.chunk(Tensor(input_x), 3)\n>>> print(output)\n(Tensor(shape=[3], dtype=Float32, value= [ 0.00000000e+00,  1.00000000e+00,  2.00000000e+00]),\n Tensor(shape=[3], dtype=Float32, value= [ 3.00000000e+00,  4.00000000e+00,  5.00000000e+00]),\n Tensor(shape=[3], dtype=Float32, value= [ 6.00000000e+00,  7.00000000e+00,  8.00000000e+00]))\n"
  },
  {
    "name": "mindspore.ops.dstack",
    "signature": "mindspore.ops.dstack(inputs)",
    "description": "Stacks tensors along the third axis.",
    "parameters": [
      "inputs (Union(List[Tensor], Tuple[Tensor])) – A sequence of tensors. The tensors must have the same shape along all but the third axis. 1-D or 2-D tensors must have the same shape."
    ],
    "returns": "Stacked Tensor, will be at least 3-D. The output shape is similar to the output of numpy.dstack() function.",
    "examples": ">>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> x1 = Tensor(np.arange(1, 7).reshape(2, 3))\n>>> x2 = Tensor(np.arange(7, 13).reshape(2, 3))\n>>> out = ops.dstack([x1, x2])\n>>> print(out.asnumpy())\n[[[ 1.  7.]\n  [ 2.  8.]\n  [ 3.  9.]]\n [[ 4. 10.]\n  [ 5. 11.]\n  [ 6. 12.]]]\n"
  },
  {
    "name": "mindspore.ops.expand_dims",
    "signature": "mindspore.ops.expand_dims(input_x, axis)",
    "description": "Adds an additional dimension to input_x at the given axis, the dimension of input_x should be greater than or equal to 1.",
    "parameters": [
      "input_x (Tensor) – The shape of tensor is \\((x_1, x_2, ..., x_R)\\).",
      "axis (int) – Specifies the dimension index at which to expand the shape of input_x. The value of axis must be in the range [-input_x.ndim-1, input_x.ndim]. Only constant value is allowed."
    ],
    "returns": "Tensor, the shape of tensor is \\((1, x_1, x_2, ..., x_R)\\) if the value of axis is 0. It has the same data type as input_x.",
    "examples": ">>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> input_tensor = Tensor(np.array([[2, 2], [2, 2]]), mindspore.float32)\n>>> output = ops.expand_dims(input_tensor, 0)\n>>> print(output)\n[[[2. 2.]\n  [2. 2.]]]\n"
  },
  {
    "name": "mindspore.ops.hsplit",
    "signature": "mindspore.ops.hsplit(input, indices_or_sections)",
    "description": "Splits a tensor into multiple sub-tensors horizontally. It is equivalent to ops.tensor_split with \\(axis=1\\) .",
    "parameters": [
      "input (Tensor) – A Tensor to be divided.",
      "indices_or_sections (Union[int, tuple(int), list(int)]) – See argument in mindspore.ops.tensor_split()."
    ],
    "returns": "A list of sub-tensors.",
    "examples": "mindspore.ops.tensor_split()\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> input_x = np.arange(6).reshape((2, 3)).astype('float32')\n>>> output = ops.hsplit(Tensor(input_x), 3)\n>>> print(output)\n(Tensor(shape=[2, 1], dtype=Float32, value=[[ 0.00000000e+00], [ 3.00000000e+00]]),\n Tensor(shape=[2, 1], dtype=Float32, value=[[ 1.00000000e+00], [ 4.00000000e+00]]),\n Tensor(shape=[2, 1], dtype=Float32, value=[[ 2.00000000e+00], [ 5.00000000e+00]]))\n"
  },
  {
    "name": "mindspore.ops.hstack",
    "signature": "mindspore.ops.hstack(tensors)",
    "description": "Stacks tensors in sequence horizontally. This is equivalent to concatenation along the second axis, except for 1-D tensors where it concatenates along the first axis.",
    "parameters": [
      "tensors (Union[tuple[Tensor], list[Tensor]]) – A sequence of tensors. The tensors must have the same shape along all but the second axis, except 1-D tensors which can be any length."
    ],
    "returns": "Stacked Tensor, formed by stacking the given tensors.",
    "examples": ">>> from mindspore import Tensor, ops\n>>> x1 = Tensor([1, 1, 1])\n>>> x2 = Tensor([2, 2, 2])\n>>> output = ops.hstack((x1, x2))\n>>> print(output)\n[1. 1. 1. 2. 2. 2.]\n"
  },
  {
    "name": "mindspore.ops.vsplit",
    "signature": "mindspore.ops.vsplit(input, indices_or_sections)",
    "description": "Splits input with two or more dimensions, into multiple sub-tensors vertically according to indices_or_sections.",
    "parameters": [
      "input (Tensor) – A Tensor to be divided.",
      "indices_or_sections (Union[int, tuple(int), list(int)]) – See argument in mindspore.ops.tensor_split()."
    ],
    "returns": "A list of sub-tensors.",
    "examples": "mindspore.ops.tensor_split()\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> input_x = np.arange(9).reshape((3, 3)).astype('float32')\n>>> output = ops.vsplit(Tensor(input_x), 3)\n>>> print(output)\n(Tensor(shape=[1, 3], dtype=Float32, value=[[ 0.00000000e+00,  1.00000000e+00,  2.00000000e+00]]),\n Tensor(shape=[1, 3], dtype=Float32, value=[[ 3.00000000e+00,  4.00000000e+00,  5.00000000e+00]]),\n Tensor(shape=[1, 3], dtype=Float32, value=[[ 6.00000000e+00,  7.00000000e+00,  8.00000000e+00]]))\n"
  },
  {
    "name": "mindspore.ops.vstack",
    "signature": "mindspore.ops.vstack(inputs)",
    "description": "Stacks tensors in sequence vertically.",
    "parameters": [
      "inputs (Union(List[tensor], Tuple[tensor])) – A sequence of 1-D or 2-D tensors. The tensors must have the same shape along all but the first axis. 1-D tensors must have the same shape."
    ],
    "returns": "Tensor, formed by stacking the given tensors, will be at least 3-D. The output shape is similar to the output of numpy.vstack() function.",
    "examples": ">>> import mindspore.numpy as np\n>>> x1 = np.array([3, 1, 4])\n>>> x2 = np.array([1, 5, 9])\n>>> out = ops.vstack([x1, x2])\n>>> print(out)\n[[3 1 4]\n [1 5 9]]\n"
  },
  {
    "name": "mindspore.ops.movedim",
    "signature": "mindspore.ops.movedim(x, source, destination)",
    "description": "Moves axis of an array from source to destination.",
    "parameters": [
      "x (Tensor) – The tensor array whose axis should be reordered. The dimension of x must not be 0.",
      "source (Union[int, sequence[int]]) – Original positions of the axis to move. The length of source and destination must be the same.",
      "destination (Union[int, sequence[int]]) – Destination positions for each of the original axis. The length of source and destination must be the same."
    ],
    "returns": "Tensor, array with moved axis.",
    "examples": ">>> # case1 : moving single axis\n>>> from mindspore import ops, Tensor\n>>> import numpy as np\n>>> x = Tensor(np.zeros((3, 4, 5)))\n>>> output = ops.movedim(x, 0, -1)\n>>> print(output.shape)\n(4, 5, 3)\n>>> # case 2 : moving multiple axes\n>>> from mindspore import ops, Tensor\n>>> import numpy as np\n>>> x = Tensor(np.zeros((3, 4, 5)))\n>>> output = ops.movedim(x, (0, 2), (1, 2))\n>>> print(output.shape)\n(4, 3, 5)\n"
  },
  {
    "name": "mindspore.ops.narrow",
    "signature": "mindspore.ops.narrow(input, axis, start, length)",
    "description": "Returns a narrowed tensor from input tensor, and the dimension axis is input from start to start + length.",
    "parameters": [
      "input (Tensor) – the tensor to narrow.",
      "axis (int) – the axis along which to narrow.",
      "start (int) – the starting dimension.",
      "length (int) – the distance to the ending dimension."
    ],
    "returns": "Tensor. output (Tensors) - The narrowed tensor.",
    "examples": ">>> import mindspore\n>>> from mindspore import ops\n>>> from mindspore import Tensor\n>>> x = Tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]], mindspore.int32)\n>>> output = ops.narrow(x, 0, 0, 2)\n>>> print(output)\n[[ 1 2 3]\n [ 4 5 6]]\n>>> output = ops.narrow(x, 1, 1, 2)\n>>> print(output)\n[[ 2 3]\n [ 5 6]\n [ 8 9]]\n"
  },
  {
    "name": "mindspore.ops.permute",
    "signature": "mindspore.ops.permute(input, axis)",
    "description": "Permutes the dimensions of the input tensor according to input axis .",
    "parameters": [
      "input (Tensor) – Input Tensor.",
      "axis (Union[tuple(int), int]) – Permute will permute the tensor to the input axis order."
    ],
    "returns": "Tensor, has the same dimension as input tensor, with axis suitably permuted.",
    "examples": ">>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> input_x = Tensor(np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]]), mindspore.float32)\n>>> input_perm = (0, 2, 1)\n>>> print(ops.permute(input_x, input_perm))\n[[[ 1.  4.]\n  [ 2.  5.]\n  [ 3.  6.]]\n [[ 7. 10.]\n  [ 8. 11.]\n  [ 9. 12.]]]\n"
  },
  {
    "name": "mindspore.ops.reshape",
    "signature": "mindspore.ops.reshape(input, shape)",
    "description": "Rearranges the input Tensor based on the given shape.",
    "parameters": [
      "input (Tensor) – The shape of tensor is \\((x_1, x_2, ..., x_R)\\).",
      "shape (Union[tuple[int], Tensor[int]]) – Constructed by multiple integers, i.e., \\((y_1, y_2, ..., y_S)\\). Only constant value is allowed."
    ],
    "returns": "Tensor, the shape of tensor is \\((y_1, y_2, ..., y_S)\\).",
    "examples": ">>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> input = Tensor(np.array([[-0.1, 0.3, 3.6], [0.4, 0.5, -3.2]]), mindspore.float32)\n>>> output = ops.reshape(input, (3, 2))\n>>> print(output)\n[[-0.1  0.3]\n [ 3.6  0.4]\n [ 0.5 -3.2]]\n"
  },
  {
    "name": "mindspore.ops.select",
    "signature": "mindspore.ops.select(cond, x, y)",
    "description": "The conditional tensor determines whether the corresponding element in the output must be selected from x (if true) or y (if false) based on the value of each element.",
    "parameters": [
      "cond (Tensor[bool]) – The condition tensor, decides which element is chosen. The shape is \\((x_1, x_2, ..., x_N, ..., x_R)\\).",
      "x (Union[Tensor, int, float]) – The first Tensor or number to be selected. If x is a Tensor, the shape is or can be broadcadt to \\((x_1, x_2, ..., x_N, ..., x_R)\\). If x is an int or a float, it will be cast to the type of int32 or float32, and broadcast to the same shape as y. One of x and y must be a Tensor.",
      "y (Union[Tensor, int, float]) – The second Tensor or number to be selected. If y is a Tensor, The shape is or can be broadcadt to \\((x_1, x_2, ..., x_N, ..., x_R)\\). If y is an int or a float, it will be cast to the type of int32 or float32, and broadcast to the same shape as x. One of x and y must be a Tensor."
    ],
    "returns": "Tensor, has the same shape as cond.",
    "examples": ">>> import mindspore\n>>> from mindspore import Tensor, ops\n>>> # 1) Both inputs are Tensor\n>>>\n>>> cond = Tensor([True, False])\n>>> x = Tensor([2,3], mindspore.float32)\n>>> y = Tensor([1,2], mindspore.float32)\n>>> output = ops.select(cond, x, y)\n>>> print(output)\n[2. 2.]\n>>> # 2) y is a float\n>>> cond = Tensor([True, False])\n>>> x = Tensor([2,3], mindspore.float32)\n>>> y = 2.0\n>>> output = ops.select(cond, x, y)\n>>> print(output)\n[2. 2.]\n"
  },
  {
    "name": "mindspore.ops.slice",
    "signature": "mindspore.ops.slice(input_x, begin, size)",
    "description": "Slices a tensor in the specified shape.",
    "parameters": [
      "input_x (Tensor) – The target tensor.",
      "begin (Union[tuple, list]) – The beginning of the slice. Only constant value(>=0) is allowed.",
      "size (Union[tuple, list]) – The size of the slice. Only constant value is allowed."
    ],
    "returns": "Tensor, the shape is input size, the data type is the same as input_x.",
    "examples": ">>> from mindspore import Tensor\n>>> from mindspore import ops\n>>> import numpy as np\n>>> data = Tensor(np.array([[[1, 1, 1], [2, 2, 2]],\n...                         [[3, 3, 3], [4, 4, 4]],\n...                         [[5, 5, 5], [6, 6, 6]]]).astype(np.int32))\n>>> output = ops.slice(data, (1, 0, 0), (1, 1, 3))\n>>> print(output)\n[[[3 3 3]]]\n>>> output = ops.slice(data, (1, 0, 0), (1, 1, 2))\n>>> print(output)\n[[[3 3]]]\n>>> output = ops.slice(data, (1, 0, 0), (1, 1, 1))\n>>> print(output)\n[[[3]]]\n>>> output = ops.slice(data, (1, 1, 0), (1, 1, 3))\n>>> print(output)\n[[[4 4 4]]]\n>>> output = ops.slice(data, (1, 0, 1), (1, 1, 2))\n>>> print(output)\n[[[3 3]]]\n"
  },
  {
    "name": "mindspore.ops.split",
    "signature": "mindspore.ops.split(tensor, split_size_or_sections, axis=0)",
    "description": "Splits the Tensor into chunks along the given axis.",
    "parameters": [
      "tensor (Tensor) – A Tensor to be divided.",
      "split_size_or_sections (Union[int, tuple(int), list(int)]) – If split_size_or_sections is an int type, tensor will be split into equally sized chunks, each chunk with size split_size_or_sections. Last chunk will be smaller than split_size_or_sections if tensor.shape[axis] is not divisible by split_size_or_sections. If split_size_or_sections is a list type, then tensor will be split into len(split_size_or_sections) chunks with sizes split_size_or_sections along the given axis.",
      "axis (int) – The axis along which to split. Default: 0 ."
    ],
    "returns": "A tuple of sub-tensors.",
    "examples": "0\n>>> import numpy as np\n>>> from mindspore import ops, Tensor\n>>> input_x = np.arange(9).astype(\"float32\")\n>>> output = ops.split(Tensor(input_x), 3)\n>>> print(output)\n(Tensor(shape=[3], dtype=Float32, value= [ 0.00000000e+00,  1.00000000e+00,  2.00000000e+00]),\n Tensor(shape=[3], dtype=Float32, value= [ 3.00000000e+00,  4.00000000e+00,  5.00000000e+00]),\n Tensor(shape=[3], dtype=Float32, value= [ 6.00000000e+00,  7.00000000e+00,  8.00000000e+00]))\n"
  },
  {
    "name": "mindspore.ops.squeeze",
    "signature": "mindspore.ops.squeeze(input, axis=None)",
    "description": "Return the Tensor after deleting the dimension of size 1 in the specified axis.",
    "parameters": [
      "input (Tensor) – The shape of tensor is \\((x_1, x_2, ..., x_R)\\).",
      "axis (Union[int, tuple(int), list(int)]) – Specifies the dimension indexes of shape to be removed, which will remove all the dimensions of size 1 in the given axis parameter. If specified, it must be int32 or int64. Default: None , an empty tuple will be used."
    ],
    "returns": "Tensor, the shape of tensor is \\((x_1, x_2, ..., x_S)\\).",
    "examples": "None\n>>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> input = Tensor(np.ones(shape=[3, 2, 1]), mindspore.float32)\n>>> output = ops.squeeze(input)\n>>> print(output)\n[[1. 1.]\n [1. 1.]\n [1. 1.]]\n"
  },
  {
    "name": "mindspore.ops.swapaxes",
    "signature": "mindspore.ops.swapaxes(input, axis0, axis1)",
    "description": "Interchange two axes of a tensor.",
    "parameters": [
      "input (Tensor) – Input tensor.",
      "axis0 (int) – First axis.",
      "axis1 (int) – Second axis."
    ],
    "returns": "Transposed tensor, has the same data type as input.",
    "examples": ">>> import numpy as np\n>>> import mindspore.ops as ops\n>>> from mindspore import Tensor\n>>> input = Tensor(np.ones((2,3,4), dtype=np.float32))\n>>> output = ops.swapaxes(input, 0, 2)\n>>> print(output.shape)\n(4, 3, 2)\n"
  },
  {
    "name": "mindspore.ops.swapdims",
    "signature": "mindspore.ops.swapdims(input, dim0, dim1)",
    "description": "Interchange two dims of a tensor. This function is equivalent to mindspore.ops.swapaxes() function.",
    "parameters": [
      "input (Tensor) – Input tensor.",
      "dim0 (int) – First dim.",
      "dim1 (int) – Second dim."
    ],
    "returns": "Transposed tensor, has the same data type as input.",
    "examples": "mindspore.ops.swapaxes()\n>>> import numpy as np\n>>> import mindspore.ops as ops\n>>> from mindspore import Tensor\n>>> input = Tensor(np.ones((2,3,4), dtype=np.float32))\n>>> output = ops.swapdims(input, 0, 2)\n>>> print(output.shape)\n(4, 3, 2)\n"
  },
  {
    "name": "mindspore.ops.t",
    "signature": "mindspore.ops.t(input)",
    "description": "Transposes a 2-D Tensor. 1-D Tensor are returned as it is.",
    "parameters": [
      "input (Tensor) – The input Tensor."
    ],
    "returns": "Tensor, the transpose of input .",
    "examples": ">>> import mindspore\n>>> from mindspore import Tensor, ops\n>>> from mindspore import dtype as mstype\n>>> x = Tensor([[1, 2, 3], [2, 3, 4]], mstype.float32)\n>>> output = ops.t(x)\n>>> print(output)\n[[1. 2.]\n [2. 3.]\n [3. 4.]]\n"
  },
  {
    "name": "mindspore.ops.tile",
    "signature": "mindspore.ops.tile(input, multiples)",
    "description": "Replicates an input tensor with given multiples times.",
    "parameters": [
      "input (Tensor) – 1-D or higher dimensional Tensor. Set the shape of input tensor as \\((x_1, x_2, ..., x_S)\\) .",
      "multiples (tuple[int]) – The parameter that specifies the number of replications, the parameter type is tuple, and the data type is int, i.e., \\((y_1, y_2, ..., y_S)\\). The length of multiples cannot be smaller than the length of the shape of input. Only constant value is allowed."
    ],
    "returns": "Tensor, has the same data type as the input. Suppose the length of multiples is d, the dimension of input is input.dim, and the shape of input is \\((x_1, x_2, ..., x_S)\\). If input.dim = d, then the shape of their corresponding positions can be multiplied, and the shape of Outputs is \\((x_1*y_1, x_2*y_2, ..., x_S*y_S)\\). If input.dim < d, fill in multiple 1 in the length of the shape of input until their lengths are consistent. Such as set the shape of input as \\((1, ..., x_1, x_2, ..., x_S)\\), then the shape of their corresponding positions can be multiplied, and the shape of Outputs is \\((1*y_1, ..., x_R*y_R, x_S*y_S)\\).",
    "examples": ">>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> input = Tensor(np.array([[1, 2], [3, 4]]), mindspore.float32)\n>>> multiples = (2, 3)\n>>> output = ops.tile(input, multiples)\n>>> print(output)\n[[1.  2.  1.  2.  1.  2.]\n [3.  4.  3.  4.  3.  4.]\n [1.  2.  1.  2.  1.  2.]\n [3.  4.  3.  4.  3.  4.]]\n>>> multiples = (2, 3, 2)\n>>> output = ops.tile(input, multiples)\n>>> print(output)\n[[[1. 2. 1. 2.]\n  [3. 4. 3. 4.]\n  [1. 2. 1. 2.]\n  [3. 4. 3. 4.]\n  [1. 2. 1. 2.]\n  [3. 4. 3. 4.]]\n [[1. 2. 1. 2.]\n  [3. 4. 3. 4.]\n  [1. 2. 1. 2.]\n  [3. 4. 3. 4.]\n  [1. 2. 1. 2.]\n  [3. 4. 3. 4.]]]\n"
  },
  {
    "name": "mindspore.ops.transpose",
    "signature": "mindspore.ops.transpose(input, input_perm)",
    "description": "Permutes the dimensions of the input tensor according to input permutation.",
    "parameters": [
      "input (Tensor) – The shape of tensor is \\((x_1, x_2, ..., x_R)\\).",
      "input_perm (tuple[int]) – The permutation to be converted. The elements in input_perm are composed of the indexes of each dimension of input. The length of input_perm and the shape of input must be the same. Only constant value is allowed. Must be in the range [-rank(input), rank(input))."
    ],
    "returns": "Tensor, the type of output tensor is the same as input and the shape of output tensor is decided by the shape of input and the value of input_perm.",
    "examples": ">>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> input = Tensor(np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]]), mindspore.float32)\n>>> input_perm = (0, 2, 1)\n>>> output = ops.transpose(input, input_perm)\n>>> print(output)\n[[[ 1.  4.]\n  [ 2.  5.]\n  [ 3.  6.]]\n [[ 7. 10.]\n  [ 8. 11.]\n  [ 9. 12.]]]\n"
  },
  {
    "name": "mindspore.ops.unbind",
    "signature": "mindspore.ops.unbind(input, dim=0)",
    "description": "Removes a tensor dimension in specified axis.",
    "parameters": [
      "input (Tensor) – The shape is \\((n_1, n_2, ..., n_R)\\). A tensor to be unstacked and the rank of the tensor must be greater than 0.",
      "dim (int) – Dimension along which to unpack. Negative values wrap around. The range is [-R, R). Default: 0 ."
    ],
    "returns": "A tuple of tensors, the shape of each objects is the same.",
    "examples": "0\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> x = Tensor(np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]))\n>>> output = ops.unbind(x, dim=0)\n>>> print(output)\n(Tensor(shape=[3], dtype=Int64, value=[1, 2, 3]), Tensor(shape=[3], dtype=Int64, value=[4, 5, 6]),\nTensor(shape=[3], dtype=Int64, value=[7, 8, 9]))\n"
  },
  {
    "name": "mindspore.ops.unsqueeze",
    "signature": "mindspore.ops.unsqueeze(input, dim)",
    "description": "Adds an additional dimension to input at the given dim.",
    "parameters": [
      "input (Tensor) – The shape of tensor is \\((n_1, n_2, ..., n_R)\\).",
      "dim (int) – Specifies the dimension index at which to expand the shape of input. The value of dim must be in the range [-input.ndim-1, input.ndim]. Only constant value is allowed."
    ],
    "returns": "Tensor, the shape of tensor is \\((1, n_1, n_2, ..., n_R)\\) if the value of dim is 0. It has the same data type as input.",
    "examples": ">>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> input_tensor = Tensor(np.array([[2, 2], [2, 2]]), mindspore.float32)\n>>> output = ops.unsqueeze(input_tensor, dim=0)\n>>> print(output)\n[[[2. 2.]\n  [2. 2.]]]\n"
  },
  {
    "name": "mindspore.ops.where",
    "signature": "mindspore.ops.where(condition, x, y)",
    "description": "Selects elements from x or y based on condition and returns a tensor.",
    "parameters": [
      "condition (Tensor[bool]) – If True, yield x, otherwise yield y.",
      "x (Union[Tensor, Scalar]) – When condition is True, values to select from.",
      "y (Union[Tensor, Scalar]) – When condition is False, values to select from."
    ],
    "returns": "Tensor, elements are selected from x and y.",
    "examples": ">>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> from mindspore import dtype as mstype\n>>> a = Tensor(np.arange(4).reshape((2, 2)), mstype.float32)\n>>> b = Tensor(np.ones((2, 2)), mstype.float32)\n>>> condition = a < 3\n>>> output = ops.where(condition, a, b)\n>>> print(output)\n[[0. 1.]\n [2. 1.]]\n"
  },
  {
    "name": "mindspore.ops.tensor_split",
    "signature": "mindspore.ops.tensor_split(input, indices_or_sections, axis=0)",
    "description": "Splits a tensor into multiple sub-tensors along the given axis.",
    "parameters": [
      "input (Tensor) – A Tensor to be divided.",
      "indices_or_sections (Union[int, tuple(int), list(int)]) – If indices_or_sections is an integer n, input tensor will be split into n sections. If \\(input.shape(axis)\\) can be divisible by n, sub-sections will have equal size \\(input.shape(axis) / n\\) . If \\(input.shape(axis)\\) is not divisible by n, the first \\(input.shape(axis) % n\\) sections will have size \\(input.shape(axis) // n + 1\\) , and the rest will have size \\(input.shape(axis) // n\\) . If indices_or_sections is of type tuple(int) or list(int), the input tensor will be split at the indices in the list or tuple. For example, given parameters \\(indices\\_or\\_sections=[1, 4]\\) and \\(axis=0\\) , the input tensor will be split into sections \\(input[:1]\\) , \\(input[1:4]\\) , and \\(input[4:]\\) .",
      "If indices_or_sections is an integer n, input tensor will be split into n sections. If \\(input.shape(axis)\\) can be divisible by n, sub-sections will have equal size \\(input.shape(axis) / n\\) . If \\(input.shape(axis)\\) is not divisible by n, the first \\(input.shape(axis) % n\\) sections will have size \\(input.shape(axis) // n + 1\\) , and the rest will have size \\(input.shape(axis) // n\\) .",
      "If \\(input.shape(axis)\\) can be divisible by n, sub-sections will have equal size \\(input.shape(axis) / n\\) .",
      "If \\(input.shape(axis)\\) is not divisible by n, the first \\(input.shape(axis) % n\\) sections will have size \\(input.shape(axis) // n + 1\\) , and the rest will have size \\(input.shape(axis) // n\\) .",
      "If indices_or_sections is of type tuple(int) or list(int), the input tensor will be split at the indices in the list or tuple. For example, given parameters \\(indices\\_or\\_sections=[1, 4]\\) and \\(axis=0\\) , the input tensor will be split into sections \\(input[:1]\\) , \\(input[1:4]\\) , and \\(input[4:]\\) .",
      "axis (int) – The axis along which to split. Default: 0 ."
    ],
    "returns": "A tuple of sub-tensors.",
    "examples": "0\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> input_x = np.arange(9).astype(\"float32\")\n>>> output = ops.tensor_split(Tensor(input_x), 3)\n>>> print(output)\n(Tensor(shape=[3], dtype=Float32, value= [ 0.00000000e+00,  1.00000000e+00,  2.00000000e+00]),\nTensor(shape=[3], dtype=Float32, value= [ 3.00000000e+00,  4.00000000e+00,  5.00000000e+00]),\nTensor(shape=[3], dtype=Float32, value= [ 6.00000000e+00,  7.00000000e+00,  8.00000000e+00]))\n"
  },
  {
    "name": "mindspore.ops.bernoulli",
    "signature": "mindspore.ops.bernoulli(input, p=0.5, seed=None)",
    "description": "Randomly set the elements of output to 0 or 1 with the probability of p which follows the Bernoulli distribution.",
    "parameters": [
      "input (Tensor) – Input Tensor. Data type must be int8, uint8, int16, int32, int64, bool, float32 or float64.",
      "p (Union[Tensor, float], optional) – Success probability, representing the probability of setting 1 for the corresponding position of the current Tensor. It has the same shape as input, the value of p must be in the range [0, 1]. Default: 0.5 .",
      "seed (Union[int, None], optional) – The seed value for random generating. The value of seed must be a positive integer. Default: None , means using the current timestamp."
    ],
    "returns": "output (Tensor), with the same shape and type as input .",
    "examples": "0.5\nNone\n>>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor\n>>> import mindspore.ops as ops\n>>> input_x = Tensor(np.array([1, 2, 3]), mindspore.int8)\n>>> output = ops.bernoulli(input_x, p=1.0)\n>>> print(output)\n[1 1 1]\n>>> input_p = Tensor(np.array([0.0, 1.0, 1.0]), mindspore.float32)\n>>> output = ops.bernoulli(input_x, input_p)\n>>> print(output)\n[0 1 1]\n"
  },
  {
    "name": "mindspore.ops.normal",
    "signature": "mindspore.ops.normal(shape, mean, stddev, seed=None)",
    "description": "Generates random numbers according to the Normal (or Gaussian) random number distribution.",
    "parameters": [
      "shape (tuple) – The shape of random tensor to be generated. The format is \\((N,*)\\) where \\(*\\) means, any number of additional dimensions.",
      "mean (Union[Tensor, int, float]) – The mean μ distribution parameter, which specifies the location of the peak.",
      "stddev (Union[Tensor, int, float]) – The deviation σ distribution parameter. It should be greater than 0.",
      "seed (int) – Seed is used as entropy source for the Random number engines to generate pseudo-random numbers. The value must be non-negative. Default: None , which will be treated as 0."
    ],
    "returns": "Tensor. The shape should be equal to the broadcasted shape between the input shape and shapes of mean and stddev. The dtype is [float32, float64].",
    "examples": "None\n>>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> shape = (3, 1, 2)\n>>> mean = Tensor(np.array([[3, 4], [5, 6]]), mindspore.float32)\n>>> stddev = Tensor(1.0, mindspore.float32)\n>>> output = ops.normal(shape, mean, stddev, seed=5)\n>>> result = output.shape\n>>> print(result)\n(3, 2, 2)\n>>> shape = (3, 1, 3)\n>>> mean = Tensor(np.array([[3, 4, 3], [3, 5, 6]]), mindspore.float32)\n>>> stddev = Tensor(1.0, mindspore.float32)\n>>> output = ops.normal(shape, mean, stddev, seed=5)\n>>> result = output.shape\n>>> print(result)\n(3, 2, 3)\n>>> shape = (3, 1, 3)\n>>> mean = Tensor(np.array([[1, 2, 3], [3, 4, 3], [3, 5, 6]]), mindspore.float32)\n>>> stddev = Tensor(1.0, mindspore.float32)\n>>> output = ops.normal(shape, mean, stddev, seed=5)\n>>> result = output.shape\n>>> print(result)\n(3, 3, 3)\n"
  },
  {
    "name": "mindspore.ops.rand",
    "signature": "mindspore.ops.rand(*size, dtype=None, seed=None)",
    "description": "Returns a new tensor that fills numbers from the uniform distribution over an interval \\([0, 1)\\) based on the given shape and dtype.",
    "parameters": [
      "size (Union[int, tuple(int), list(int)]) – Shape of the new tensor, e.g. \\((2, 3)\\) or \\(2\\)."
    ],
    "returns": "Tensor, with the designated shape and dtype, filled with random numbers from the uniform distribution on the interval \\([0, 1)\\).",
    "examples": "mindspore.dtype\nNone\nNone\n0\n>>> import mindspore.ops as ops\n>>> print(ops.rand((2,3)))\n[[4.1702199e-01 9.9718481e-01 7.2032452e-01]\n [9.3255734e-01 1.1438108e-04 1.2812445e-01]]\n"
  },
  {
    "name": "mindspore.ops.randint",
    "signature": "mindspore.ops.randint(low, high, size, seed=None, *, dtype=None)",
    "description": "Returns a Tensor whose elements are random integers in the range of [ low , high ) .",
    "parameters": [
      "low (int) – Start value of interval.",
      "high (int) – End value of interval.",
      "size (tuple) – Shape of the new tensor.",
      "seed (int, optional) – Random seed, must be greater or equal to 0. Default: None , and 0 will be used."
    ],
    "returns": "Tensor, with the designated shape and dtype, filled with random integers from low (inclusive) to high (exclusive).",
    "examples": "None\n0\nmindspore.dtype\nNone\nNone\n>>> import mindspore.ops as ops\n>>> print(ops.randint(1, 10, (2,3)))\n[[4 9 7]\n [9 1 2]]\n"
  },
  {
    "name": "mindspore.ops.randn",
    "signature": "mindspore.ops.randn(*size, dtype=None, seed=None)",
    "description": "Returns a new Tensor with given shape and dtype, filled with a sample (or samples) from the standard normal distribution.",
    "parameters": [
      "size (Union[int, tuple(int), list(int)]) – Shape of the new tensor, e.g., \\((2, 3)\\) or \\(2\\)."
    ],
    "returns": "Tensor, with the designated shape and dtype, filled with a sample (or samples) from the “standard normal” distribution.",
    "examples": "mindspore.dtype\nNone\nNone\n>>> import mindspore.ops as ops\n>>> print(ops.randn((2, 2)))\n[[ 0.30639967 -0.42438635]\n [-0.4287376   1.3054721 ]]\n"
  },
  {
    "name": "mindspore.ops.randperm",
    "signature": "mindspore.ops.randperm(n, seed=0, offset=0, dtype=mstype.int64)",
    "description": "Generates random permutation of integers from 0 to n-1.",
    "parameters": [
      "n (Union[Tensor, int]) – The input n Tensor with shape: () or (1,) and with data type of int64. The value of n must be greater than zero.",
      "seed (int, optional) – Random seed. Default: 0 . When seed is -1(only negative value), offset is 0, it’s determined by time.",
      "offset (int, optional) – Offset to generate random numbers. Priority is higher than random seed. Default: 0 . It must be non-negative.",
      "dtype (mindspore.dtype, optional) – The type of output. Its value must be one of the following types: int32, int16, int8, uint8, int64, float64, float32, float16. Default: mstype.int64."
    ],
    "returns": "Tensor. Its shape is specified by the required args n. Its type is specified by dtype. Otherwise is default.",
    "examples": "0\n0\n>>> from mindspore import ops\n>>> from mindspore import dtype as mstype\n>>> n = 4\n>>> seed = 0\n>>> offset = 0\n>>> output = ops.randperm(n, seed, offset, dtype=mstype.int64)\n>>> print(output)\n[1 0 2 3]\n"
  },
  {
    "name": "mindspore.ops.multinomial",
    "signature": "mindspore.ops.multinomial(input, num_samples, replacement=True, seed=None)",
    "description": "Returns a tensor sampled from the multinomial probability distribution located in the corresponding row of the input tensor.",
    "parameters": [
      "input (Tensor) – The input tensor containing probabilities, must be 1 or 2 dimensions, with float32 data type.",
      "num_samples (int) – Number of samples to draw.",
      "replacement (bool, optional) – Whether to draw with replacement or not. Default: True .",
      "seed (int, optional) – Seed is used as entropy source for the random number engines to generate pseudo-random numbers, must be non-negative. Default: None ."
    ],
    "returns": "Tensor, has the same rows with input. The number of sampled indices of each row is num_samples. The dtype is float32.",
    "examples": "True\nNone\n>>> import mindspore\n>>> from mindspore import Tensor, ops\n>>> from mindspore import dtype as mstype\n>>> # case 1: The output is random, and the length of the output is the same as num_sample.\n>>> # replacement is False.\n>>> input1 = Tensor([90 / 100, 10 / 100, 0], mindspore.float32)\n>>> input2 = Tensor([90, 10, 0], mindspore.float32)\n>>> # input1 and input2 have the same meaning.\n>>> output1 = ops.multinomial(input1, 2, replacement=False)\n>>> output2 = ops.multinomial(input2, 2, replacement=False)\n>>> # print(output1)\n>>> # [0 1]\n>>> # print(output2)\n>>> # [0 1]\n>>> print(len(output1))\n2\n>>> print(len(output2))\n2\n>>> # case 2: The output is random, and the length of the output is the same as num_sample.\n>>> # replacement is True.\n>>> output3 = ops.multinomial(input1, 10)\n>>> # print(output3)\n>>> # [0 0 1 0 0 0 0 0 0 0]\n>>> print(len(output3))\n10\n>>> # case 3: The output is random, and the length of the output is the same as num_sample.\n>>> # replacement is True.\n>>> # rank is 2\n>>> input4 = Tensor([[90, 10, 0], [10, 90, 0]], mstype.float32)\n>>> output4 = ops.multinomial(input4, 10)\n>>> # print(output4)\n>>> # [[0 0 0 0 0 0 0 0 1 0]\n>>> #  [1 1 1 1 1 0 1 1 1 1]]\n"
  },
  {
    "name": "mindspore.ops.abs",
    "signature": "mindspore.ops.abs(input)",
    "description": "Returns absolute value of a tensor element-wise.",
    "parameters": [
      "input (Tensor) – The input tensor. The shape of tensor is \\((N,*)\\) where \\(*\\) means, any number of additional dimensions."
    ],
    "returns": "Tensor, has the same shape as the input.",
    "examples": ">>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> input = Tensor(np.array([-1.0, 1.0, 0.0]), mindspore.float32)\n>>> output = ops.abs(input)\n>>> print(output)\n[1. 1. 0.]\n"
  },
  {
    "name": "mindspore.ops.acos",
    "signature": "mindspore.ops.acos(input)",
    "description": "Computes arccosine of input tensors element-wise.",
    "parameters": [
      "input (Tensor) – The shape of tensor is \\((N,*)\\) where \\(*\\) means, any number of additional dimensions."
    ],
    "returns": "Tensor, has the same shape and dtype as input.",
    "examples": ">>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> input = Tensor(np.array([0.74, 0.04, 0.30, 0.56]), mindspore.float32)\n>>> output = ops.acos(input)\n>>> print(output)\n[0.737726  1.5307857 1.2661036 0.9764105]\n"
  },
  {
    "name": "mindspore.ops.acosh",
    "signature": "mindspore.ops.acosh(input)",
    "description": "Computes inverse hyperbolic cosine of the inputs element-wise.",
    "parameters": [
      "input (Tensor) – The input tensor of inverse hyperbolic cosine function."
    ],
    "returns": "Tensor, has the same shape and type as input.",
    "examples": ">>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> x = Tensor(np.array([1.0, 1.5, 3.0, 100.0]), mindspore.float32)\n>>> output = ops.acosh(x)\n>>> print(output)\n[0.        0.9624237 1.7627472 5.298292 ]\n"
  },
  {
    "name": "mindspore.ops.arccos",
    "signature": "mindspore.ops.arccos(input)",
    "description": "Alias for mindspore.ops.acos() .",
    "parameters": [],
    "returns": "",
    "examples": ""
  },
  {
    "name": "mindspore.ops.arccosh",
    "signature": "mindspore.ops.arccosh(input)",
    "description": "Alias for mindspore.ops.acosh().",
    "parameters": [],
    "returns": "",
    "examples": "mindspore.ops.acosh()\n>>> import mindspore\n>>> from mindspore import Tensor, ops\n>>> import numpy as np\n>>> x = Tensor(np.array([1.0, 1.5, 3.0, 100.0]), mindspore.float32)\n>>> output = ops.arccosh(x)\n>>> print(output)\n[0.        0.9624237 1.7627472 5.298292 ]\n"
  },
  {
    "name": "mindspore.ops.add",
    "signature": "mindspore.ops.add(input, other)",
    "description": "Adds other value to input Tensor.",
    "parameters": [
      "input (Union[Tensor, number.Number, bool]) – The first input is a number.Number or a bool or a tensor whose data type is number or bool_.",
      "other (Union[Tensor, number.Number, bool]) – The second input, when the first input is a Tensor, the second input should be a number.Number or bool value, or a Tensor whose data type is number or bool. When the first input is Scalar, the second input must be a Tensor whose data type is number or bool."
    ],
    "returns": "Tensor, the shape is the same as the one of the input input , other after broadcasting, and the data type is the one with higher precision or higher digits among the two inputs.",
    "examples": ">>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> # case 1: x and y are both Tensor.\n>>> x = Tensor(np.array([1, 2, 3]).astype(np.float32))\n>>> y = Tensor(np.array([4, 5, 6]).astype(np.float32))\n>>> output = ops.add(x, y)\n>>> print(output)\n[5. 7. 9.]\n>>> # case 2: x is a scalar and y is a Tensor\n>>> x = Tensor(1, mindspore.int32)\n>>> y = Tensor(np.array([4, 5, 6]).astype(np.float32))\n>>> output = ops.add(x, y)\n>>> print(output)\n[5. 6. 7.]\n>>> # the data type of x is int32, the data type of y is float32,\n>>> # and the output is the data format of higher precision float32.\n>>> print(output.dtype)\nFloat32\n"
  },
  {
    "name": "mindspore.ops.addcdiv",
    "signature": "mindspore.ops.addcdiv(input, tensor1, tensor2, value=1)",
    "description": "Performs the element-wise division of tensor tensor1 by tensor tensor2, multiply the result by the scalar value and add it to input_data.",
    "parameters": [
      "input (Tensor) – The tensor to be added.",
      "tensor1 (Tensor) – The numerator tensor.",
      "tensor2 (Tensor) – The denominator tensor.",
      "value (Union[Tensor, Number]) – The multiplier for tensor1/tensor2. Default: 1 ."
    ],
    "returns": "Tensor, has the same shape and dtype as tensor1/tensor2.",
    "examples": "1\n>>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> input_data = Tensor(np.array([1, 1, 1, 1]), mindspore.float32)\n>>> x1 = Tensor(np.array([1, 2, 3, 4]), mindspore.float32)\n>>> x2 = Tensor(np.array([4, 3, 2, 1]), mindspore.float32)\n>>> value = Tensor([1], mindspore.float32)\n>>> y = ops.addcdiv(input_data, x1, x2, value)\n>>> print(y)\n[1.25      1.6666667 2.5       5.       ]\n"
  },
  {
    "name": "mindspore.ops.addcmul",
    "signature": "mindspore.ops.addcmul(input, tensor1, tensor2, value=1)",
    "description": "Performs the element-wise product of tensor tensor1 and tensor tensor2, multiply the result by the scalar value and add it to input_data.",
    "parameters": [
      "input (Tensor) – The tensor to be added.",
      "tensor1 (Tensor) – The tensor to be multiplied.",
      "tensor2 (Tensor) – The tensor to be multiplied.",
      "value (Union[Tensor, Number]) – The multiplier for tensor1*tensor2. Default: 1 ."
    ],
    "returns": "Tensor, has the same shape and dtype as x1*x2.",
    "examples": "1\n>>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> input_data = Tensor(np.array([1, 1, 1]), mindspore.float32)\n>>> x1 = Tensor(np.array([[1], [2], [3]]), mindspore.float32)\n>>> x2 = Tensor(np.array([[1, 2, 3]]), mindspore.float32)\n>>> value = Tensor([1], mindspore.float32)\n>>> y = ops.addcmul(input_data, x1, x2, value)\n>>> print(y)\n[[ 2.  3.  4.]\n [ 3.  5.  7.]\n [ 4.  7. 10.]]\n"
  },
  {
    "name": "mindspore.ops.asin",
    "signature": "mindspore.ops.asin(input)",
    "description": "Computes arcsine of input tensors element-wise.",
    "parameters": [
      "input (Tensor) – The shape of tensor is \\((N,*)\\) where \\(*\\) means, any number of additional dimensions."
    ],
    "returns": "Tensor, has the same shape and dtype as input.",
    "examples": ">>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> x = Tensor(np.array([0.74, 0.04, 0.30, 0.56]), mindspore.float32)\n>>> output = ops.asin(x)\n>>> print(output)\n[0.8330704  0.04001067  0.30469266  0.5943858 ]\n"
  },
  {
    "name": "mindspore.ops.asinh",
    "signature": "mindspore.ops.asinh(input)",
    "description": "Computes inverse hyperbolic sine of the input element-wise.",
    "parameters": [
      "input (Tensor) – The input tensor of inverse hyperbolic sine function."
    ],
    "returns": "Tensor, has the same shape and type as input.",
    "examples": ">>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> input = Tensor(np.array([-5.0, 1.5, 3.0, 100.0]), mindspore.float32)\n>>> output = ops.asinh(input)\n>>> print(output)\n[-2.3124382  1.1947632  1.8184465  5.298342 ]\n"
  },
  {
    "name": "mindspore.ops.arcsin",
    "signature": "mindspore.ops.arcsin(x)",
    "description": "Alias for mindspore.ops.asin().",
    "parameters": [],
    "returns": "",
    "examples": ""
  },
  {
    "name": "mindspore.ops.arcsinh",
    "signature": "mindspore.ops.arcsinh(input)",
    "description": "Alias for mindspore.ops.asinh().",
    "parameters": [],
    "returns": "",
    "examples": ""
  },
  {
    "name": "mindspore.ops.atan",
    "signature": "mindspore.ops.atan(input)",
    "description": "Computes the trigonometric inverse tangent of the input element-wise.",
    "parameters": [
      "input (Tensor) – The shape of tensor is \\((N,*)\\) where \\(*\\) means, any number of additional dimensions. The data type should be one of the following types: float16, float32."
    ],
    "returns": "A Tensor, has the same type as the input.",
    "examples": ">>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> x = Tensor(np.array([1.0, 0.0]), mindspore.float32)\n>>> output = ops.atan(x)\n>>> print(output)\n[0.7853982 0.       ]\n"
  },
  {
    "name": "mindspore.ops.atanh",
    "signature": "mindspore.ops.atanh(input)",
    "description": "Computes inverse hyperbolic tangent of the input element-wise.",
    "parameters": [
      "input (Tensor) – The shape of tensor is \\((N,*)\\) where \\(*\\) means, any number of additional dimensions. The data type should be one of the following types: float16, float32."
    ],
    "returns": "A Tensor, has the same type as the input.",
    "examples": ">>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> input = Tensor(np.array([0, -0.5]), mindspore.float32)\n>>> output = ops.atanh(input)\n>>> print(output)\n[ 0.         -0.54930615]\n"
  },
  {
    "name": "mindspore.ops.arctan",
    "signature": "mindspore.ops.arctan(input)",
    "description": "Alias for mindspore.ops.atan().",
    "parameters": [],
    "returns": "",
    "examples": "mindspore.ops.atan()\n>>> import mindspore\n>>> from mindspore import Tensor, ops\n>>> import numpy as np\n>>> x = Tensor(np.array([1.0, 0.0]), mindspore.float32)\n>>> output = ops.arctan(x)\n>>> print(output)\n[0.7853982 0.       ]\n"
  },
  {
    "name": "mindspore.ops.arctanh",
    "signature": "mindspore.ops.arctanh(input)",
    "description": "Alias for mindspore.ops.atanh().",
    "parameters": [],
    "returns": "",
    "examples": ""
  },
  {
    "name": "mindspore.ops.atan2",
    "signature": "mindspore.ops.atan2(input, other)",
    "description": "Returns arctangent of input/other element-wise.",
    "parameters": [
      "input (Tensor) – The input tensor with shape \\((N,*)\\) where \\(*\\) means, any number of additional dimensions. The data type should be one of the following types: float16, float32, float64",
      "other (Tensor) – The input tensor. It has the same shape with input or its shape is able to broadcast with input."
    ],
    "returns": "Tensor, the shape is the same as the one after broadcasting, and the data type is same as input.",
    "examples": ">>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> input = Tensor(np.array([0, 1]), mindspore.float32)\n>>> other = Tensor(np.array([1, 1]), mindspore.float32)\n>>> output = ops.atan2(input, other)\n>>> print(output)\n[0.        0.7853982]\n"
  },
  {
    "name": "mindspore.ops.ceil",
    "signature": "mindspore.ops.ceil(input)",
    "description": "Rounds a tensor up to the closest integer element-wise.",
    "parameters": [
      "input (Tensor) – The input tensor with a dtype of float16 or float32."
    ],
    "returns": "Tensor, has the same shape as the input.",
    "examples": ">>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> x = Tensor(np.array([1.1, 2.5, -1.5]), mindspore.float32)\n>>> output = ops.ceil(x)\n>>> print(output)\n[ 2.  3. -1.]\n"
  },
  {
    "name": "mindspore.ops.clamp",
    "signature": "mindspore.ops.clamp(input, min=None, max=None)",
    "description": "Clamps tensor values between the specified minimum value and maximum value.",
    "parameters": [
      "input (Union(Tensor, list[Tensor], tuple[Tensor])) – Input data, which type is Tensor or a list or tuple of Tensor. Tensors of arbitrary dimensions are supported.",
      "min (Union(Tensor, float, int), optional) – The minimum value. Default: None .",
      "max (Union(Tensor, float, int), optional) – The maximum value. Default: None ."
    ],
    "returns": "Union(Tensor, tuple[Tensor], list[Tensor]), a clipped Tensor or a tuple or a list of clipped Tensor. The data type and shape are the same as input.",
    "examples": "None\nNone\n>>> # case 1: the data type of input is Tensor\n>>> import mindspore\n>>> from mindspore import Tensor, ops\n>>> import numpy as np\n>>> min_value = Tensor(5, mindspore.float32)\n>>> max_value = Tensor(20, mindspore.float32)\n>>> input = Tensor(np.array([[1., 25., 5., 7.], [4., 11., 6., 21.]]), mindspore.float32)\n>>> output = ops.clamp(input, min_value, max_value)\n>>> print(output)\n[[ 5. 20.  5.  7.]\n [ 5. 11.  6. 20.]]\n>>> # case 2: the data type of input is list[Tensor]\n>>> min_value = 5\n>>> max_value = 20\n>>> input_x = Tensor(np.array([[1., 25., 5., 7.], [4., 11., 6., 21.]]), mindspore.float32)\n>>> input_y = Tensor(np.array([[1., 25., 5., 7.], [4., 11., 6., 21.]]), mindspore.float32)\n>>> output = ops.clamp([input_x,input_y], min_value, max_value)\n>>> for out in output:\n...     print(out)\n[[ 5. 20.  5.  7.]\n [ 5. 11.  6. 20.]]\n[[ 5. 20.  5.  7.]\n [ 5. 11.  6. 20.]]\n"
  },
  {
    "name": "mindspore.ops.cos",
    "signature": "mindspore.ops.cos(input)",
    "description": "Computes cosine of input element-wise.",
    "parameters": [
      "input (Tensor) – The shape of tensor is \\((N,*)\\) where \\(*\\) means, any number of additional dimensions."
    ],
    "returns": "Tensor, has the same shape and dtype as input.",
    "examples": ">>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> x = Tensor(np.array([0.24, 0.83, 0.31, 0.09]), mindspore.float32)\n>>> output = ops.cos(x)\n>>> print(output)\n[0.971338 0.6748758 0.95233357 0.9959527]\n"
  },
  {
    "name": "mindspore.ops.cosh",
    "signature": "mindspore.ops.cosh(input)",
    "description": "Computes hyperbolic cosine of input element-wise.",
    "parameters": [
      "input (Tensor) – The input tensor of hyperbolic cosine function, its data type must be float16, float32, float64, complex64 or complex128."
    ],
    "returns": "Tensor, has the same shape as input.",
    "examples": ">>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> x = Tensor(np.array([0.24, 0.83, 0.31, 0.09]), mindspore.float32)\n>>> output = ops.cosh(x)\n>>> print(output)\n[1.0289385 1.364684 1.048436 1.0040528]\n>>> x = Tensor(2.1, mindspore.float32)\n>>> output = ops.cosh(x)\n>>> print(output)\n4.144313\n"
  },
  {
    "name": "mindspore.ops.div",
    "signature": "mindspore.ops.div(input, other, *, rounding_mode=None)",
    "description": "Divides the first input tensor by the second input tensor in floating-point type element-wise.",
    "parameters": [
      "input (Union[Tensor, Number, bool]) – The first input is a number or a bool or a tensor whose data type is number or bool.",
      "other (Union[Tensor, Number, bool]) – The second input is a number or a bool when the first input is a tensor or a tensor whose data type is number or bool."
    ],
    "returns": "Tensor, the shape is the same as the one after broadcasting, and the data type is the one with higher precision or higher digits among the two inputs.",
    "examples": "None\n>>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> x = Tensor(np.array([1.0, 2.0, 3.0]), mindspore.float32)\n>>> y = Tensor(np.array([4.0, 5.0, 6.0]), mindspore.float32)\n>>> output = ops.div(x, y)\n>>> print(output)\n[0.25 0.4 0.5]\n"
  },
  {
    "name": "mindspore.ops.erf",
    "signature": "mindspore.ops.erf(input)",
    "description": "Computes the Gauss error function of input element-wise.",
    "parameters": [
      "Ascend: float16, float32.",
      "GPU/CPU: float16, float32, float64."
    ],
    "returns": "Tensor, has the same shape and dtype as the input.",
    "examples": ">>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> x = Tensor(np.array([-1, 0, 1, 2, 3]), mindspore.float32)\n>>> output = ops.erf(x)\n>>> print(output)\n[-0.8427168   0.          0.8427168   0.99530876  0.99997765]\n"
  },
  {
    "name": "mindspore.ops.erfc",
    "signature": "mindspore.ops.erfc(input)",
    "description": "Computes the complementary error function of input element-wise.",
    "parameters": [
      "Ascend: float16, float32.",
      "GPU/CPU: float16, float32, float64."
    ],
    "returns": "Tensor, has the same shape and dtype as input.",
    "examples": ">>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> x = Tensor(np.array([-1, 0, 1, 2, 3]), mindspore.float32)\n>>> output = ops.erfc(x)\n>>> print(output)\n[1.8427168e+00 1.0000000e+00 1.5728319e-01 4.6912432e-03 2.2351742e-05]\n"
  },
  {
    "name": "mindspore.ops.erfinv",
    "signature": "mindspore.ops.erfinv(input)",
    "description": "Returns the result of the inverse error function with input, which is defined in the range (-1, 1) as:",
    "parameters": [
      "Ascend: float16, float32.",
      "GPU/CPU: float16, float32, float64."
    ],
    "returns": "Tensor, has the same shape and dtype as input.",
    "examples": ">>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> x = Tensor(np.array([0, 0.5, -0.9]), mindspore.float32)\n>>> output = ops.erfinv(x)\n>>> print(output)\n[ 0.          0.47695306 -1.1630805 ]\n"
  },
  {
    "name": "mindspore.ops.exp",
    "signature": "mindspore.ops.exp(input)",
    "description": "Returns exponential of a tensor element-wise.",
    "parameters": [
      "input (Tensor) – The input tensor."
    ],
    "returns": "Tensor, has the same shape and dtype as the input.",
    "examples": ">>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> x = Tensor(np.array([1.0, 2.0, 4.0]), mindspore.float32)\n>>> output = ops.exp(x)\n>>> print(output)\n[ 2.718282  7.389056 54.598152]\n"
  },
  {
    "name": "mindspore.ops.expm1",
    "signature": "mindspore.ops.expm1(input)",
    "description": "Returns exponential then minus 1 of a tensor element-wise.",
    "parameters": [
      "input (Tensor) – The input Tensor."
    ],
    "returns": "Tensor, has the same shape as the input.",
    "examples": ">>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> x = Tensor(np.array([0.0, 1.0, 2.0, 4.0]), mindspore.float32)\n>>> output = ops.expm1(x)\n>>> print(output)\n[ 0.        1.718282  6.389056 53.598152]\n"
  },
  {
    "name": "mindspore.ops.floor",
    "signature": "mindspore.ops.floor(input)",
    "description": "Rounds a tensor down to the closest integer element-wise.",
    "parameters": [
      "input (Tensor) – The input tensor, its data type must be float16, float32 or float64."
    ],
    "returns": "Tensor, has the same shape as input.",
    "examples": ">>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> x = Tensor(np.array([1.1, 2.5, -1.5]), mindspore.float32)\n>>> output = ops.floor(x)\n>>> print(output)\n[ 1.  2. -2.]\n"
  },
  {
    "name": "mindspore.ops.fmod",
    "signature": "mindspore.ops.fmod(input, other)",
    "description": "Computes the floating-point remainder of the division operation input/other.",
    "parameters": [
      "input (Union[Tensor, Number]) – the dividend.",
      "other (Union[Tensor, Number]) – the divisor."
    ],
    "returns": "Tensor, the shape is the same as the one after broadcasting, and the data type is the one with higher precision or higher digits among the two inputs.",
    "examples": ">>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> input = Tensor(np.array([-4., -3.5, 0, 3.5, 4]), mindspore.float32)\n>>> output = ops.fmod(input, 2.5)\n>>> print(output)\n[-1.5 -1.   0.   1.   1.5]\n"
  },
  {
    "name": "mindspore.ops.gelu",
    "signature": "mindspore.ops.gelu(input_x, approximate='none')",
    "description": "Gaussian Error Linear Units activation function.",
    "parameters": [
      "input_x (Tensor) – The input of the activation function GeLU, the data type is float16, float32 or float64.",
      "approximate (str) – the gelu approximation algorithm to use. Acceptable vaslues are 'none' and 'tanh' . Default: 'none' ."
    ],
    "returns": "Tensor, with the same type and shape as input_x.",
    "examples": "'none'\n'tanh'\n'none'\n>>> import mindspore\n>>> from mindspore import Tensor, ops\n>>> x = Tensor([1.0, 2.0, 3.0], mindspore.float32)\n>>> result = ops.gelu(x)\n>>> print(result)\n[0.841192 1.9545976 2.9963627]\n"
  },
  {
    "name": "mindspore.ops.log",
    "signature": "mindspore.ops.log(input)",
    "description": "Returns the natural logarithm of a tensor element-wise.",
    "parameters": [
      "input (Tensor) – Input Tensor of any dimension. The value must be greater than 0."
    ],
    "returns": "Tensor, has the same shape and dtype as the input.",
    "examples": ">>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> x = Tensor(np.array([1.0, 2.0, 4.0]), mindspore.float32)\n>>> output = ops.log(x)\n>>> print(output)\n[0.        0.6931472 1.3862944]\n"
  },
  {
    "name": "mindspore.ops.log1p",
    "signature": "mindspore.ops.log1p(input)",
    "description": "Returns the natural logarithm of one plus the input tensor element-wise.",
    "parameters": [
      "input (Tensor) – The input tensor. The value must be greater than -1."
    ],
    "returns": "Tensor, has the same shape as the input.",
    "examples": ">>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> x = Tensor(np.array([1.0, 2.0, 4.0]), mindspore.float32)\n>>> output = ops.log1p(x)\n>>> print(output)\n[0.6931472 1.0986123 1.609438 ]\n"
  },
  {
    "name": "mindspore.ops.log2",
    "signature": "mindspore.ops.log2(input)",
    "description": "Returns a new Tensor by taking the base 2 logarithm of the elements in the input Tensor.",
    "parameters": [
      "input (Tensor) – Input Tensor of any dimension. The value must be greater than 0."
    ],
    "returns": "Tensor, has the same shape and dtype as the input.",
    "examples": ">>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> x = Tensor(np.array([2, 4, 8]).astype(np.float16))\n>>> output = ops.log2(x)\n>>> print(output)\n[1. 2. 3.]\n"
  },
  {
    "name": "mindspore.ops.log10",
    "signature": "mindspore.ops.log10(input)",
    "description": "Returns a new Tensor by taking the base 10 logarithm of the elements in the input Tensor.",
    "parameters": [
      "input (Tensor) – Input Tensor of any dimension. The each element in Tensor must be greater than 0."
    ],
    "returns": "Tensor, has the same shape and dtype as the input.",
    "examples": ">>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> x = Tensor(np.array([2, 4, 10]).astype(np.float16))\n>>> output = ops.log10(x)\n>>> print(output)\n[0.301 0.602 1.   ]\n"
  },
  {
    "name": "mindspore.ops.logical_and",
    "signature": "mindspore.ops.logical_and(input, other)",
    "description": "Computes the “logical AND” of two tensors element-wise.",
    "parameters": [
      "input (Union[Tensor, bool]) – The first input is a bool or a tensor whose data type can be implicitly converted to bool.",
      "other (Union[Tensor, bool]) – The second input is a bool when the first input is a tensor or a tensor whose data type can be implicitly converted to bool."
    ],
    "returns": "Tensor, the shape is the same as the one after broadcasting, and the data type is bool.",
    "examples": ">>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> x = Tensor(np.array([True, False, True]), mindspore.bool_)\n>>> y = Tensor(np.array([True, True, False]), mindspore.bool_)\n>>> output = ops.logical_and(x, y)\n>>> print(output)\n[ True False False]\n>>> x = Tensor(1, mindspore.bool_)\n>>> y = Tensor(0, mindspore.bool_)\n>>> output = ops.logical_and(x, y)\n>>> print(output)\nFalse\n>>> x = True\n>>> y = Tensor(0, mindspore.bool_)\n>>> output = ops.logical_and(x, y)\n>>> print(output)\nFalse\n>>> x = True\n>>> y = Tensor(np.array([True, False]), mindspore.bool_)\n>>> output = ops.logical_and(x, y)\n>>> print(output)\n[True False]\n"
  },
  {
    "name": "mindspore.ops.logical_not",
    "signature": "mindspore.ops.logical_not(input)",
    "description": "Computes the “logical NOT” of a tensor element-wise.",
    "parameters": [
      "input (Tensor) – The input tensor, the dtype must be bool."
    ],
    "returns": "Tensor, the shape is the same as the input, and the dtype is bool.",
    "examples": ">>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> x = Tensor(np.array([True, False, True]), mindspore.bool_)\n>>> output = ops.logical_not(x)\n>>> print(output)\n[False  True False]\n"
  },
  {
    "name": "mindspore.ops.logical_or",
    "signature": "mindspore.ops.logical_or(input, other)",
    "description": "Computes the “logical OR” of two tensors element-wise.",
    "parameters": [
      "input (Union[Tensor, bool]) – The first input is a bool or a tensor whose data type can be implicitly converted to bool.",
      "other (Union[Tensor, bool]) – The second input is a bool when the first input is a tensor or a tensor whose data type can be implicitly converted to bool."
    ],
    "returns": "Tensor, the shape is the same as the one after broadcasting, and the data type is bool.",
    "examples": ">>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> x = Tensor(np.array([True, False, True]), mindspore.bool_)\n>>> y = Tensor(np.array([True, True, False]), mindspore.bool_)\n>>> output = ops.logical_or(x, y)\n>>> print(output)\n[ True  True  True]\n>>> x = Tensor(1, mindspore.bool_)\n>>> y = Tensor(0, mindspore.bool_)\n>>> output = ops.logical_or(x, y)\n>>> print(output)\nTrue\n>>> x = True\n>>> y = Tensor(0, mindspore.bool_)\n>>> output = ops.logical_or(x, y)\n>>> print(output)\nTrue\n>>> x = True\n>>> y = Tensor(np.array([True, False]), mindspore.bool_)\n>>> output = ops.logical_or(x, y)\n>>> print(output)\n[True True]\n"
  },
  {
    "name": "mindspore.ops.logical_xor",
    "signature": "mindspore.ops.logical_xor(input, other)",
    "description": "Computes the “logical XOR” of two tensors element-wise.",
    "parameters": [
      "input (Tensor) – The first input is a tensor whose data type can be implicitly converted to bool.",
      "other (Tensor) – The second input is a tensor whose data type can be implicitly converted to bool to compute XOR with the first input."
    ],
    "returns": "Tensor, the shape is the same as the one after broadcasting, and the data type is bool.",
    "examples": ">>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> x = Tensor(np.array([True, False, True]), mindspore.bool_)\n>>> y = Tensor(np.array([True, True, False]), mindspore.bool_)\n>>> output = ops.logical_xor(x, y)\n>>> print(output)\n[False True True]\n>>> x = Tensor(1, mindspore.bool_)\n>>> y = Tensor(0, mindspore.bool_)\n>>> output = ops.logical_xor(x, y)\n>>> print(output)\nTrue\n>>> x = True\n>>> y = Tensor(0, mindspore.bool_)\n>>> output = ops.logical_xor(x, y)\n>>> print(output)\nTrue\n>>> x = True\n>>> y = Tensor(np.array([True, False]), mindspore.bool_)\n>>> output = ops.logical_xor(x, y)\n>>> print(output)\n[False True]\n"
  },
  {
    "name": "mindspore.ops.bitwise_and",
    "signature": "mindspore.ops.bitwise_and(input, other)",
    "description": "Returns bitwise and of two tensors element-wise.",
    "parameters": [
      "input (Tensor) – The first input tensor with shape \\((N, *)\\) where \\(*\\) means any number of additional dimensions.",
      "other (Tensor) – The second input tensor with the same dtype as input."
    ],
    "returns": "Tensor, has the same type as the input.",
    "examples": ">>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> input = Tensor(np.array([0, 0, 1, -1, 1, 1, 1]), mindspore.int16)\n>>> other = Tensor(np.array([0, 1, 1, -1, -1, 2, 3]), mindspore.int16)\n>>> output = ops.bitwise_and(input, other)\n>>> print(output)\n[ 0  0  1 -1  1  0  1]\n"
  },
  {
    "name": "mindspore.ops.bitwise_or",
    "signature": "mindspore.ops.bitwise_or(input, other)",
    "description": "Returns bitwise or of two tensors element-wise.",
    "parameters": [
      "input (Tensor) – The first input tensor with shape \\((N, *)\\) where \\(*\\) means any number of additional dimensions.",
      "other (Tensor) – The second input tensor with the same dtype as input."
    ],
    "returns": "Tensor, has the same type as the input.",
    "examples": ">>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> input = Tensor(np.array([0, 0, 1, -1, 1, 1, 1]), mindspore.int16)\n>>> other = Tensor(np.array([0, 1, 1, -1, -1, 2, 3]), mindspore.int16)\n>>> output = ops.bitwise_or(input, other)\n>>> print(output)\n[ 0  1  1 -1 -1  3  3]\n"
  },
  {
    "name": "mindspore.ops.bitwise_xor",
    "signature": "mindspore.ops.bitwise_xor(input, other)",
    "description": "Returns bitwise xor of two tensors element-wise.",
    "parameters": [
      "input (Tensor) – The first input tensor with shape \\((N, *)\\) where \\(*\\) means any number of additional dimensions.",
      "other (Tensor) – The second input tensor with the same dtype as input."
    ],
    "returns": "Tensor, has the same type as the input.",
    "examples": ">>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> input = Tensor(np.array([0, 0, 1, -1, 1, 1, 1]), mindspore.int16)\n>>> other = Tensor(np.array([0, 1, 1, -1, -1, 2, 3]), mindspore.int16)\n>>> output = ops.bitwise_xor(input, other)\n>>> print(output)\n[ 0  1  0  0 -2  3  2]\n"
  },
  {
    "name": "mindspore.ops.mish",
    "signature": "mindspore.ops.mish(x)",
    "description": "Computes MISH(A Self Regularized Non-Monotonic Neural Activation Function) of input tensors element-wise.",
    "parameters": [
      "GPU/CPU: float16, float32, float64.",
      "Ascend: float16, float32."
    ],
    "returns": "Tensor, with the same type and shape as the x.",
    "examples": ">>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> input_x = Tensor(np.array([[-1.0, 4.0, -8.0], [2.0, -5.0, 9.0]]), mindspore.float32)\n>>> output = ops.mish(input_x)\n>>> print(output)\n[[-3.0340147e-01  3.9974129e+00 -2.68311895e-03]\n [ 1.9439590e+00  -3.3576239e-02 8.99999990e+00]]\n>>> input_x = Tensor(2.1, mindspore.float32)\n>>> output = ops.mish(input_x)\n>>> print(output)\n2.050599\n"
  },
  {
    "name": "mindspore.ops.mul",
    "signature": "mindspore.ops.mul(input, other)",
    "description": "Multiplies two tensors element-wise.",
    "parameters": [
      "input (Union[Tensor, number.Number, bool]) – The first input is a number.Number or a bool or a tensor whose data type is number or bool_.",
      "other (Union[Tensor, number.Number, bool]) – The second input, when the first input is a Tensor, the second input should be a number.Number or bool value, or a Tensor whose data type is number or bool. When the first input is Scalar, the second input must be a Tensor whose data type is number or bool."
    ],
    "returns": "Tensor, the shape is the same as the one after broadcasting, and the data type is the one with higher precision or higher digits among the two inputs.",
    "examples": ">>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> x = Tensor(np.array([1.0, 2.0, 3.0]), mindspore.float32)\n>>> y = Tensor(np.array([4.0, 5.0, 6.0]), mindspore.float32)\n>>> output = ops.mul(x, y)\n>>> print(output)\n[ 4. 10. 18.]\n"
  },
  {
    "name": "mindspore.ops.neg",
    "signature": "mindspore.ops.neg(input)",
    "description": "Returns a tensor with negative values of the input tensor element-wise.",
    "parameters": [
      "input (Tensor) – The input tensor with a dtype of Number."
    ],
    "returns": "Tensor, has the same shape and dtype as input.",
    "examples": ">>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> input = Tensor(np.array([1, 2, -1, 2, 0, -3.5]), mindspore.float32)\n>>> output = ops.neg(input)\n>>> print(output)\n[-1.  -2.   1.  -2.   0.   3.5]\n"
  },
  {
    "name": "mindspore.ops.negative",
    "signature": "mindspore.ops.negative(input)",
    "description": "Alias for mindspore.ops.neg() .",
    "parameters": [],
    "returns": "",
    "examples": ""
  },
  {
    "name": "mindspore.ops.pow",
    "signature": "mindspore.ops.pow(input, exponent)",
    "description": "Calculates the exponent power of each element in input.",
    "parameters": [
      "input (Union[Tensor, number.Number, bool]) – The first input is a number.Number or a bool or a tensor whose data type is number or bool_.",
      "exponent (Union[Tensor, number.Number, bool]) – The second input, when the first input is a Tensor, the second input should be a number.Number or bool value, or a Tensor whose data type is number or bool_. When the first input is Scalar, the second input must be a Tensor whose data type is number or bool_."
    ],
    "returns": "Tensor, the shape is the same as the one after broadcasting, and the data type is the one with higher precision or higher digits among the two inputs.",
    "examples": ">>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> x = Tensor(np.array([1.0, 2.0, 4.0]), mindspore.float32)\n>>> y = 3.0\n>>> output = ops.pow(x, y)\n>>> print(output)\n[ 1.  8. 64.]\n>>>\n>>> x = Tensor(np.array([1.0, 2.0, 4.0]), mindspore.float32)\n>>> y = Tensor(np.array([2.0, 4.0, 3.0]), mindspore.float32)\n>>> output = ops.pow(x, y)\n>>> print(output)\n[ 1. 16. 64.]\n"
  },
  {
    "name": "mindspore.ops.reciprocal",
    "signature": "mindspore.ops.reciprocal(input)",
    "description": "Returns reciprocal of a tensor element-wise.",
    "parameters": [
      "input (Tensor) – The input tensor. \\((N, *)\\) where \\(*\\) means, any number of additional dimensions."
    ],
    "returns": "Tensor, has the same shape as the input.",
    "examples": ">>> import mindspore as ms\n>>> import mindspore.ops as ops\n>>> import numpy as np\n>>> input = ms.Tensor(np.array([1.0, 2.0, 4.0]), ms.float32)\n>>> output = ops.reciprocal(input)\n>>> print(output)\n[1.   0.5  0.25]\n"
  },
  {
    "name": "mindspore.ops.round",
    "signature": "mindspore.ops.round(input)",
    "description": "Returns half to even of a tensor element-wise.",
    "parameters": [
      "input (Tensor) – The input tensor."
    ],
    "returns": "Tensor, has the same shape and type as the input.",
    "examples": ">>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> input = Tensor(np.array([0.8, 1.5, 2.3, 2.5, -4.5]), mindspore.float32)\n>>> output = ops.round(input)\n>>> print(output)\n[ 1.  2.  2.  2. -4.]\n"
  },
  {
    "name": "mindspore.ops.rsqrt",
    "signature": "mindspore.ops.rsqrt(input)",
    "description": "Computes reciprocal of square root of input tensor element-wise.",
    "parameters": [
      "input (Tensor) – The input of rsqrt. Its each element must be a non-negative number, if an element is negative, the calculation result is nan."
    ],
    "returns": "Tensor, has the same shape and dtype as the input.",
    "examples": ">>> import mindspore as ms\n>>> import mindspore.ops as ops\n>>> input = ms.Tensor([-0.0370,  0.2970,  1.5420, -0.9105])\n>>> output = ops.rsqrt(input)\n>>> print(output)\n[       nan 1.8349396  0.80530024        nan]\n"
  },
  {
    "name": "mindspore.ops.selu",
    "signature": "mindspore.ops.selu(input_x)",
    "description": "Activation function SeLU (Scaled exponential Linear Unit).",
    "parameters": [
      "input_x (Tensor) – Tensor of any dimension, the data type is float16 or float32."
    ],
    "returns": "Tensor, with the same type and shape as the input_x.",
    "examples": ">>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> input_x = Tensor(np.array([[-1.0, 4.0, -8.0], [2.0, -5.0, 9.0]]), mindspore.float32)\n>>> output = ops.selu(input_x)\n>>> print(output)\n[[-1.1113307 4.202804 -1.7575096]\n[ 2.101402 -1.7462534 9.456309 ]]\n"
  },
  {
    "name": "mindspore.ops.softmax",
    "signature": "mindspore.ops.softmax(x, axis=- 1, *, dtype=None)",
    "description": "Applies the Softmax operation to the input tensor on the specified axis. Suppose a slice in the given axis \\(x\\), then for each element \\(x_i\\), the Softmax function is shown as follows:",
    "parameters": [
      "axis (Union[int, tuple[int]], optional) – The axis to perform the Softmax operation. Default: -1 .",
      "x (Tensor) – Tensor of shape \\((N, *)\\), where \\(*\\) means, any number of additional dimensions, with float16 or float32 data type."
    ],
    "returns": "Tensor, with the same type and shape as the logits.",
    "examples": "-1\nmindspore.dtype\nNone\n>>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> x = Tensor(np.array([1, 2, 3, 4, 5]), mindspore.float32)\n>>> output = ops.softmax(x)\n>>> print(output)\n[0.01165623 0.03168492 0.08612854 0.23412167 0.6364086 ]\n"
  },
  {
    "name": "mindspore.ops.softsign",
    "signature": "mindspore.ops.softsign(x)",
    "description": "Softsign activation function.",
    "parameters": [
      "x (Tensor) – Tensor of shape \\((N, *)\\), where \\(*\\) means, any number of additional dimensions, with float16 or float32 data type."
    ],
    "returns": "Tensor, with the same type and shape as the x.",
    "examples": ">>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> x = Tensor(np.array([0, -1, 2, 30, -30]), mindspore.float32)\n>>> output = ops.softsign(x)\n>>> print(output)\n[ 0.        -0.5         0.6666667  0.9677419 -0.9677419]\n"
  },
  {
    "name": "mindspore.ops.silu",
    "signature": "mindspore.ops.silu(x)",
    "description": "Computes Sigmoid Linear Unit of input element-wise. The SiLU function is defined as:",
    "parameters": [],
    "returns": "",
    "examples": "mindspore.nn.SiLU\n>>> import numpy as np\n>>> import mindspore\n>>> from mindspore import Tensor, ops\n>>> x = Tensor(np.array([-1, 2, -3, 2, -1]), mindspore.float16)\n>>> output = ops.silu(x)\n>>> print(output)\n[-0.269  1.762  -0.1423  1.762  -0.269]\n"
  },
  {
    "name": "mindspore.ops.sigmoid",
    "signature": "mindspore.ops.sigmoid(input)",
    "description": "Computes Sigmoid of input element-wise. The Sigmoid function is defined as:",
    "parameters": [
      "input (Tensor) – Tensor of any dimension, the data type is float16, float32, float64, complex64 or complex128."
    ],
    "returns": "Tensor, with the same type and shape as the input.",
    "examples": ">>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> input = Tensor(np.array([1, 2, 3, 4, 5]), mindspore.float32)\n>>> output = ops.sigmoid(input)\n>>> print(output)\n[0.7310586  0.880797   0.95257413 0.98201376 0.9933072 ]\n"
  },
  {
    "name": "mindspore.ops.sign",
    "signature": "mindspore.ops.sign(input)",
    "description": "Returns an element-wise indication of the sign of a number.",
    "parameters": [
      "input (Tensor) – Input Tensor."
    ],
    "returns": "Tensor, the sign of input.",
    "examples": ">>> import mindspore as ms\n>>> import mindspore.ops as ops\n>>> input = ms.Tensor([[-1, 0, 2, 4, 6], [2, 3, 5, -6, 0]])\n>>> output = ops.sign(input)\n>>> print(output)\n[[-1  0  1  1  1]\n [ 1  1  1 -1  0]]\n>>> ms.set_context(device_target=\"\")\n>>> x = ms.Tensor([[-1, 0, float('inf'), 4, float('nan')], [2, 3, float('-inf'), -6, 0]])\n>>> output = ops.sign(x)\n>>> print(output)\n[[-1.  0.  1.  1.  0.]\n [ 1.  1. -1. -1.  0.]]\n"
  },
  {
    "name": "mindspore.ops.sin",
    "signature": "mindspore.ops.sin(input)",
    "description": "Computes sine of the input element-wise.",
    "parameters": [
      "input (Tensor) – The shape of tensor is \\((N,*)\\) where \\(*\\) means, any number of additional dimensions."
    ],
    "returns": "Tensor, has the same shape and dtype as input.",
    "examples": ">>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> input = Tensor(np.array([0.62, 0.28, 0.43, 0.62]), mindspore.float32)\n>>> output = ops.sin(input)\n>>> print(output)\n[0.5810352 0.27635565 0.41687083 0.5810352]\n"
  },
  {
    "name": "mindspore.ops.sinh",
    "signature": "mindspore.ops.sinh(input)",
    "description": "Computes hyperbolic sine of the input element-wise.",
    "parameters": [
      "input (Tensor) – The input tensor of hyperbolic sine function."
    ],
    "returns": "Tensor, has the same shape as input.",
    "examples": ">>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> input = Tensor(np.array([0.62, 0.28, 0.43, 0.62]), mindspore.float32)\n>>> output = ops.sinh(input)\n>>> print(output)\n[0.6604918  0.28367308 0.44337422 0.6604918 ]\n"
  },
  {
    "name": "mindspore.ops.sqrt",
    "signature": "mindspore.ops.sqrt(x)",
    "description": "Returns sqrt of a tensor element-wise.",
    "parameters": [
      "x (Tensor) – The input tensor with a dtype of number.Number."
    ],
    "returns": "Tensor, has the same shape and dtype as the x.",
    "examples": ">>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> x = Tensor(np.array([1.0, 4.0, 9.0]), mindspore.float32)\n>>> output = ops.sqrt(x)\n>>> print(output)\n[1. 2. 3.]\n"
  },
  {
    "name": "mindspore.ops.square",
    "signature": "mindspore.ops.square(input)",
    "description": "Returns square of a tensor element-wise.",
    "parameters": [
      "input (Tensor) – The input tensor with a dtype of Number."
    ],
    "returns": "Tensor, has the same shape and dtype as the input.",
    "examples": ">>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> input = Tensor(np.array([1.0, 2.0, 3.0]), mindspore.float32)\n>>> output = ops.square(input)\n>>> print(output)\n[1. 4. 9.]\n"
  },
  {
    "name": "mindspore.ops.sub",
    "signature": "mindspore.ops.sub(input, other)",
    "description": "Subtracts the second input tensor from the first input tensor element-wise.",
    "parameters": [
      "input (Union[Tensor, number.Number, bool]) – The first input is a number.Number or a bool or a tensor whose data type is number or bool_.",
      "other (Union[Tensor, number.Number, bool]) – The second input, when the first input is a Tensor, the second input should be a number.Number or bool value, or a Tensor whose data type is number or bool. When the first input is Scalar, the second input must be a Tensor whose data type is number or bool."
    ],
    "returns": "Tensor, the shape is the same as the one after broadcasting, and the data type is the one with higher precision or higher digits among the two inputs.",
    "examples": ">>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> input = Tensor(np.array([1, 2, 3]), mindspore.int32)\n>>> other = Tensor(np.array([4, 5, 6]), mindspore.int32)\n>>> output = ops.sub(input, other)\n>>> print(output)\n[-3 -3 -3]\n"
  },
  {
    "name": "mindspore.ops.tan",
    "signature": "mindspore.ops.tan(input)",
    "description": "Computes tangent of input element-wise.",
    "parameters": [
      "input (Tensor) – The input Tensor, valid for any dimensions."
    ],
    "returns": "Tensor, has the same shape as input.",
    "examples": ">>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> input = Tensor(np.array([-1.0, 0.0, 1.0]), mindspore.float32)\n>>> output = ops.tan(input)\n>>> print(output)\n[-1.5574081 0. 1.5574081]\n"
  },
  {
    "name": "mindspore.ops.tanh",
    "signature": "mindspore.ops.tanh(input)",
    "description": "Computes hyperbolic tangent of input element-wise. The Tanh function is defined as:",
    "parameters": [
      "input (Tensor) – Input of Tanh."
    ],
    "returns": "Tensor, with the same type and shape as the input.",
    "examples": ">>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> input = Tensor(np.array([1, 2, 3, 4, 5]), mindspore.float32)\n>>> output = ops.tanh(input)\n>>> print(output)\n[0.7615941 0.9640276 0.9950547 0.9993293 0.9999092]\n"
  },
  {
    "name": "mindspore.ops.trunc",
    "signature": "mindspore.ops.trunc(input)",
    "description": "Returns a new tensor with the truncated integer values of the elements of the input tensor.",
    "parameters": [
      "input (Tensor) – The input tensor."
    ],
    "returns": "Tensor, the same shape and data type as the input.",
    "examples": ">>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> x = Tensor(np.array([3.4742, 0.5466, -0.8008, -3.9079]),mindspore.float32)\n>>> output = ops.trunc(x)\n>>> print(output)\n[3. 0. 0. -3.]\n"
  },
  {
    "name": "mindspore.ops.lerp",
    "signature": "mindspore.ops.lerp(input, end, weight)",
    "description": "Does a linear interpolation of two tensors input and end based on a float or tensor weight.",
    "parameters": [
      "input (Tensor) – The tensor with the starting points. Data type must be float16 or float32.",
      "end (Tensor) – The tensor with the ending points. Data type must be the same as input.",
      "weight (Union[float, Tensor]) – The weight for the interpolation formula. Must be a float or a scalar tensor with float16 or float32 data type."
    ],
    "returns": "Tensor, has the same type and shape as input input.",
    "examples": ">>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> input = Tensor(np.array([1., 2., 3., 4.]), mindspore.float32)\n>>> end = Tensor(np.array([10., 10., 10., 10.]), mindspore.float32)\n>>> output = ops.lerp(input, end, 0.5)\n>>> print(output)\n[5.5 6. 6.5 7. ]\n"
  },
  {
    "name": "mindspore.ops.argmax",
    "signature": "mindspore.ops.argmax(input, dim=None, keepdim=False)",
    "description": "Return the indices of the maximum values of a tensor across a dimension.",
    "parameters": [
      "input (Tensor) – Input tensor.",
      "dim (Union[int, None], optional) – The dimension to reduce. If dim is None , the indices of the maximum value within the flattened input will be returned. Default: None .",
      "keepdim (bool, optional) – Whether the output tensor retains the specified dimension. Ignored if dim is None. Default: False ."
    ],
    "returns": "Tensor, indices of the maximum values across a dimension.",
    "examples": "None\nNone\nFalse\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> x = Tensor(np.array([[1, 20, 5], [67, 8, 9], [130, 24, 15]]).astype(np.float32))\n>>> output = ops.argmax(x, dim=-1)\n>>> print(output)\n[1 0 0]\n"
  },
  {
    "name": "mindspore.ops.argmin",
    "signature": "mindspore.ops.argmin(input, axis=None, keepdims=False)",
    "description": "Returns the indices of the minimum value of a tensor across the axis.",
    "parameters": [
      "input (Tensor) – Input tensor.",
      "axis (Union[int, None], optional) – Axis where the Argmin operation applies to. Default: None .",
      "keepdims (bool, optional) – Whether the output tensor retains the specified dimension. Ignored if axis is None. Default: False ."
    ],
    "returns": "Tensor, indices of the min value of input tensor across the axis.",
    "examples": "None\nFalse\n>>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> input_x = Tensor(np.array([2.0, 3.1, 1.2]), mindspore.float32)\n>>> index = ops.argmin(input_x)\n>>> print(index)\n2\n"
  },
  {
    "name": "mindspore.ops.amax",
    "signature": "mindspore.ops.amax(input, axis=None, keepdims=False, *, initial=None, where=None)",
    "description": "Reduces all dimensions of a tensor by returning the maximum value in input, by default. And also can reduce a dimension of input along specified axis. keepdims determines whether the dimensions of output and input are the same.",
    "parameters": [
      "input (Tensor[Number]) – The input tensor. The dtype of the tensor to be reduced is number. \\((N, *)\\) where \\(*\\) means, any number of additional dimensions.",
      "axis (Union[int, tuple(int), list(int)]) – The dimensions to reduce. Default: None , reduce all dimensions. Only constant value is allowed. Assume the rank of x is r, and the value range is [-r,r).",
      "keepdims (bool) – If true, keep these reduced dimensions and the length is 1. If false, don’t keep these dimensions. Default: False ."
    ],
    "returns": "Tensor, has the same data type as input tensor. If axis is None, and keepdims is False, the output is a 0-D tensor representing the product of all elements in the input tensor. If axis is int, set as 1, and keepdims is False, the shape of output is \\((x_0, x_2, ..., x_R)\\). If axis is tuple(int), set as (1, 2), and keepdims is False, the shape of output is \\((x_0, x_3, ..., x_R)\\).",
    "examples": "None\nFalse\nNone\nNone\n>>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> x = Tensor(np.random.randn(3, 4, 5, 6).astype(np.float32))\n>>> output = ops.amax(x, 1, keepdims=True)\n>>> result = output.shape\n>>> print(result)\n(3, 1, 5, 6)\n>>> # case 1: Reduces a dimension by the maximum value of all elements in the dimension.\n>>> x = Tensor(np.array([[[1, 1, 1, 1, 1, 1], [2, 2, 2, 2, 2, 2], [3, 3, 3, 3, 3, 3]],\n...                      [[4, 4, 4, 4, 4, 4], [5, 5, 5, 5, 5, 5], [6, 6, 6, 6, 6, 6]],\n...                      [[7, 7, 7, 7, 7, 7], [8, 8, 8, 8, 8, 8], [9, 9, 9, 9, 9, 9]]]), mindspore.float32)\n>>> output = ops.amax(x)\n>>> print(output)\n9.0\n>>> print(output.shape)\n()\n>>> # case 2: Reduces a dimension along axis 0.\n>>> output = ops.amax(x, 0, True)\n>>> print(output)\n[[[7. 7. 7. 7. 7. 7.]\n  [8. 8. 8. 8. 8. 8.]\n  [9. 9. 9. 9. 9. 9.]]]\n>>> # case 3: Reduces a dimension along axis 1.\n>>> output = ops.amax(x, 1, True)\n>>> print(output)\n[[[3. 3. 3. 3. 3. 3.]]\n [[6. 6. 6. 6. 6. 6.]]\n [[9. 9. 9. 9. 9. 9.]]]\n>>> # case 4: Reduces a dimension along axis 2.\n>>> output = ops.amax(x, 2, True)\n>>> print(output)\n[[[1.]\n  [2.]\n  [3.]]\n [[4.]\n  [5.]\n  [6.]]\n [[7.]\n  [8.]\n  [9.]]]\n"
  },
  {
    "name": "mindspore.ops.amin",
    "signature": "mindspore.ops.amin(input, axis=None, keepdims=False, *, initial=None, where=None)",
    "description": "Reduces all dimensions of a tensor by returning the minimum value in input, by default. And also can reduce a dimension of input along specified axis. keepdims determines whether the dimensions of output and input are the same.",
    "parameters": [
      "input (Tensor[Number]) – The input tensor. The dtype of the tensor to be reduced is number. \\((N, *)\\) where \\(*\\) means, any number of additional dimensions.",
      "axis (Union[int, tuple(int), list(int)]) – The dimensions to reduce. Default: None , reduce all dimensions. Only constant value is allowed. Assume the rank of x is r, and the value range is [-r,r).",
      "keepdims (bool) – If true, keep these reduced dimensions and the length is 1. If false, don’t keep these dimensions. Default: False ."
    ],
    "returns": "Tensor, has the same data type as input tensor. If axis is None, and keepdims is False, the output is a 0-D tensor representing the product of all elements in the input tensor. If axis is int, set as 1, and keepdims is False, the shape of output is \\((x_0, x_2, ..., x_R)\\). If axis is tuple(int), set as (1, 2), and keepdims is False, the shape of output is \\((x_0, x_3, ..., x_R)\\).",
    "examples": "None\nFalse\nNone\nNone\n>>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> x = Tensor(np.random.randn(3, 4, 5, 6).astype(np.float32))\n>>> output = ops.amin(x, 1, keepdims=True)\n>>> result = output.shape\n>>> print(result)\n(3, 1, 5, 6)\n>>> # case 1: Reduces a dimension by the minimum value of all elements in the dimension.\n>>> x = Tensor(np.array([[[1, 1, 1, 1, 1, 1], [2, 2, 2, 2, 2, 2], [3, 3, 3, 3, 3, 3]],\n...                      [[4, 4, 4, 4, 4, 4], [5, 5, 5, 5, 5, 5], [6, 6, 6, 6, 6, 6]],\n...                      [[7, 7, 7, 7, 7, 7], [8, 8, 8, 8, 8, 8], [9, 9, 9, 9, 9, 9]]]), mindspore.float32)\n>>> output = ops.amin(x)\n>>> print(output)\n1.0\n>>> print(output.shape)\n()\n>>> # case 2: Reduces a dimension along axis 0.\n>>> output = ops.amin(x, 0, True)\n>>> print(output)\n[[[1. 1. 1. 1. 1. 1.]\n  [2. 2. 2. 2. 2. 2.]\n  [3. 3. 3. 3. 3. 3.]]]\n>>> # case 3: Reduces a dimension along axis 1.\n>>> output = ops.amin(x, 1, True)\n>>> print(output)\n[[[1. 1. 1. 1. 1. 1.]]\n [[4. 4. 4. 4. 4. 4.]]\n [[7. 7. 7. 7. 7. 7.]]]\n>>> # case 4: Reduces a dimension along axis 2.\n>>> output = ops.amin(x, 2, True)\n>>> print(output)\n[[[1.]\n  [2.]\n  [3.]]\n [[4.]\n  [5.]\n  [6.]]\n [[7.]\n  [8.]\n  [9.]]]\n"
  },
  {
    "name": "mindspore.ops.any",
    "signature": "mindspore.ops.any(input, axis=None, keep_dims=False)",
    "description": "Reduces a dimension of input by the “logical OR” of all elements in the dimension, by default. And also can reduce a dimension of input along the axis. Determine whether the dimensions of the output and input are the same by controlling keep_dims.",
    "parameters": [
      "input (Tensor) – Input Tensor, has the shape \\((N, *)\\) where \\(*\\) means, any number of additional dimensions.",
      "axis (Union[int, tuple(int), list(int)], optional) – The dimensions to reduce. Suppose the rank of input is r, axis must be in the range [-rank(input), rank(input)). Default: None , all dimensions are reduced.",
      "keep_dims (bool, optional) – If true, keep these reduced dimensions and the length is 1. If false, don’t keep these dimensions. Default : False ."
    ],
    "returns": "Tensor, the dtype is bool. If axis is None, and keep_dims is False , the output is a 0-D Tensor representing the “logical OR” of all elements in the input Tensor. If axis is int, such as 2, and keep_dims is False , the shape of output is \\((input_1, input_3, ..., input_R)\\). If axis is tuple(int), such as (2, 3), and keep_dims is False , the shape of output is \\((input_1, input_4, ..., input_R)\\).",
    "examples": "None\nFalse\nFalse\nFalse\nFalse\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> x = Tensor(np.array([[True, False], [True, True]]))\n>>> # case 1: Reduces a dimension by the \"logical OR\" of all elements in the dimension.\n>>> output = ops.any(x, keep_dims=True)\n>>> print(output)\n[[ True]]\n>>> print(output.shape)\n(1, 1)\n>>> # case 2: Reduces a dimension along axis 0.\n>>> output = ops.any(x, axis=0)\n>>> print(output)\n[ True True]\n>>> # case 3: Reduces a dimension along axis 1.\n>>> output = ops.any(x, axis=1)\n>>> print(output)\n[ True True]\n"
  },
  {
    "name": "mindspore.ops.max",
    "signature": "mindspore.ops.max(input, axis=None, keepdims=False, *, initial=None, where=None)",
    "description": "Calculates the maximum value along with the given axis for the input tensor. It returns the maximum values and indices.",
    "parameters": [
      "input (Tensor) – The input tensor, can be any dimension. Complex tensor is not supported for now.",
      "axis (int) – The dimension to reduce. When axis is None, computing the maximum value of all elements in input .Default: None .",
      "keepdims (bool) – Whether to reduce dimension, if true, the output will keep same dimension with the input, the output will reduce dimension if false. Default: False ."
    ],
    "returns": "tuple (Tensor), tuple of 2 tensors, containing the corresponding index and the maximum value of the input tensor. values (Tensor) - The maximum value of input tensor, with the same shape as index, and same dtype as x. index (Tensor) - The index for the maximum value of the input tensor, with dtype int32. If keepdims is true, the shape of output tensors is \\((input_1, input_2, ..., input_{axis-1}, 1, input_{axis+1}, ..., input_N)\\) . Otherwise, the shape is \\((input_1, input_2, ..., input_{axis-1}, input_{axis+1}, ..., input_N)\\) .",
    "examples": "None\nmindspore.ops.ArgMaxWithValue\nNone\nNone\nFalse\nNone\nTrue\nTrue\nNone\nTrue\n>>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> x = Tensor(np.array([0.0, 0.4, 0.6, 0.7, 0.1]), mindspore.float32)\n>>> output, index = ops.max(x)\n>>> print(output, index)\n0.7 0\n>>> y = Tensor(np.array([[0.0, 0.3, 0.4, 0.5, 0.1],\n...                      [3.2, 0.4, 0.1, 2.9, 4.0]]), mindspore.float32)\n>>> output, index = ops.max(y, axis=0, keepdims=True)\n>>> print(output, index)\n[[3.2 0.4 0.4 2.9 4. ]] [[1 1 0 1 1]]\n"
  },
  {
    "name": "mindspore.ops.min",
    "signature": "mindspore.ops.min(input, axis=None, keepdims=False, *, initial=None, where=None)",
    "description": "Calculates the minimum value along with the given axis for the input tensor. It returns the minimum values and indices.",
    "parameters": [
      "input (Tensor) – The input tensor, can be any dimension. Complex tensor is not supported for now.",
      "axis (int) – The dimension to reduce. Default: None .",
      "keepdims (bool) – Whether to reduce dimension, if True the output will keep the same dimension as the input, the output will reduce dimension if False . Default: False ."
    ],
    "returns": "tuple (Tensor), tuple of 2 tensors, containing the corresponding index and the minimum value of the input tensor. values (Tensor) - The minimum value of input tensor, with the same shape as index, and same dtype as x. index (Tensor) - The index for the minimum value of the input tensor, with dtype int32. If keepdims is true, the shape of output tensors is \\((input_1, input_2, ..., input_{axis-1}, 1, input_{axis+1}, ..., input_N)\\) . Otherwise, the shape is \\((input_1, input_2, ..., input_{axis-1}, input_{axis+1}, ..., input_N)\\) .",
    "examples": "None\nNone\nTrue\nFalse\nFalse\nNone\nTrue\nTrue\nNone\nTrue\n>>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> x = Tensor(np.array([0.0, 0.4, 0.6, 0.7, 0.1]), mindspore.float32)\n>>> output, index = ops.min(x, keepdims=True)\n>>> print(output, index)\n0.0 0\n"
  },
  {
    "name": "mindspore.ops.mean",
    "signature": "mindspore.ops.mean(x, axis=None, keep_dims=False)",
    "description": "Reduces all dimension of a tensor by averaging all elements in the dimension, by default. And reduce a dimension of x along the specified axis. keep_dims determines whether the dimensions of the output and input are the same.",
    "parameters": [
      "x (Tensor[Number]) – The input tensor. The dtype of the tensor to be reduced is number. \\((N, *)\\) where \\(*\\) means, any number of additional dimensions.",
      "axis (Union[int, tuple(int), list(int)]) – The dimensions to reduce. Default: None , reduce all dimensions. Only constant value is allowed. Assume the rank of x is r, and the value range is [-r,r).",
      "keep_dims (bool) – If true, keep these reduced dimensions and the length is 1. If false, don’t keep these dimensions. Default: False ."
    ],
    "returns": "Tensor, has the same data type as input tensor. If axis is None, and keep_dims is False, the output is a 0-D tensor representing the product of all elements in the input tensor. If axis is int, set as 1, and keep_dims is False, the shape of output is \\((x_0, x_2, ..., x_R)\\). If axis is tuple(int), set as (1, 2), and keep_dims is False , the shape of output is \\((x_0, x_3, ..., x_R)\\).",
    "examples": "None\nFalse\nFalse\n>>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> x = Tensor(np.random.randn(3, 4, 5, 6).astype(np.float32))\n>>> output = ops.mean(x, 1, keep_dims=True)\n>>> result = output.shape\n>>> print(result)\n(3, 1, 5, 6)\n>>> # case 1: Reduces a dimension by averaging all elements in the dimension.\n>>> x = Tensor(np.array([[[2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2]],\n... [[4, 4, 4, 4, 4, 4], [5, 5, 5, 5, 5, 5], [6, 6, 6, 6, 6, 6]],\n... [[6, 6, 6, 6, 6, 6], [8, 8, 8, 8, 8, 8], [10, 10, 10, 10, 10, 10]]]),\n... mindspore.float32)\n>>> output = ops.mean(x)\n>>> print(output)\n5.0\n>>> print(output.shape)\n()\n>>> # case 2: Reduces a dimension along the axis 0\n>>> output = ops.mean(x, 0, True)\n>>> print(output)\n[[[4. 4. 4. 4. 4. 4.]\n  [5. 5. 5. 5. 5. 5.]\n  [6. 6. 6. 6. 6. 6.]]]\n>>> # case 3: Reduces a dimension along the axis 1\n>>> output = ops.mean(x, 1, True)\n>>> print(output)\n[[[2. 2. 2. 2. 2. 2.]]\n [[5. 5. 5. 5. 5. 5.]]\n [[8. 8. 8. 8. 8. 8.]]]\n>>> # case 4: Reduces a dimension along the axis 2\n>>> output = ops.mean(x, 2, True)\n>>> print(output)\n[[[ 2.]\n  [ 2.]\n  [ 2.]]\n [[ 4.]\n  [ 5.]\n  [ 6.]]\n [[ 6.]\n  [ 8.]\n  [10.]]]\n"
  },
  {
    "name": "mindspore.ops.median",
    "signature": "mindspore.ops.median(input, axis=- 1, keepdims=False)",
    "description": "Computes the median and indices of input tensor.",
    "parameters": [
      "input (Tensor) – A Tensor of any dimension whose data type is int16, int32, int64, float32 or float64.",
      "axis (int, optional) – The dimension need to reduce. Default: -1 .",
      "keepdims (bool, optional) – Whether the output tensor need to retain axis dimension or not. Default: False ."
    ],
    "returns": "y (Tensor), has the same dtype as the input. If keepdims is true, the y has the same shape as the input except the shape of y in dimension axis is size 1. Otherwise, the y lacks axis dimension than input. indices (Tensor), has the same shape as the y, but dtype is int64.",
    "examples": "-1\nFalse\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> x = Tensor(np.array([[0.57, 0.11, 0.21],[0.38, 0.50, 0.57], [0.36, 0.16, 0.44]]).astype(np.float32))\n>>> y = ops.median(x, axis=0, keepdims=False)\n>>> print(y)\n(Tensor(shape=[3], dtype=Float32, value= [ 3.79999995e-01,  1.59999996e-01,  4.39999998e-01]),\nTensor(shape=[3], dtype=Int64, value= [1, 2, 2]))\n"
  },
  {
    "name": "mindspore.ops.prod",
    "signature": "mindspore.ops.prod(input, axis=None, keep_dims=False)",
    "description": "Reduces a dimension of a tensor by multiplying all elements in the dimension, by default. And also can reduce a dimension of input along the axis. Determine whether the dimensions of the output and input are the same by controlling keep_dims.",
    "parameters": [
      "input (Tensor[Number]) – The input tensor. The dtype of the tensor to be reduced is number. \\((N, *)\\) where \\(*\\) means, any number of additional dimensions.",
      "axis (Union[int, tuple(int), list(int)]) – The dimensions to reduce. Default: None , reduce all dimensions. Only constant value is allowed. Assume the rank of input is r, and the value range is [-r,r).",
      "keep_dims (bool) – If true, keep these reduced dimensions and the length is 1. If false, don’t keep these dimensions. Default: False ."
    ],
    "returns": "Tensor, has the same data type as input tensor. If axis is None, and keep_dims is False, the output is a 0-D tensor representing the product of all elements in the input tensor. If axis is int, set as 1, and keep_dims is False, the shape of output is \\((input_0, input_2, ..., input_R)\\). If axis is tuple(int), set as (1, 2), and keep_dims is False, the shape of output is \\((input_0, input_3, ..., input_R)\\).",
    "examples": "None\nFalse\n>>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> x = Tensor(np.random.randn(3, 4, 5, 6).astype(np.float32))\n>>> output = ops.prod(x, 1, keep_dims=True)\n>>> result = output.shape\n>>> print(result)\n(3, 1, 5, 6)\n>>> # case 1: Reduces a dimension by multiplying all elements in the dimension.\n>>> x = Tensor(np.array([[[1, 1, 1, 1, 1, 1], [2, 2, 2, 2, 2, 2], [3, 3, 3, 3, 3, 3]],\n...                      [[4, 4, 4, 4, 4, 4], [5, 5, 5, 5, 5, 5], [6, 6, 6, 6, 6, 6]],\n...                      [[7, 7, 7, 7, 7, 7], [8, 8, 8, 8, 8, 8], [9, 9, 9, 9, 9, 9]]]), mindspore.float32)\n>>> output = ops.prod(x)\n>>> print(output)\n2.2833798e+33\n>>> print(output.shape)\n()\n>>> # case 2: Reduces a dimension along axis 0.\n>>> output = ops.prod(x, 0, True)\n>>> print(output)\n[[[ 28.  28.  28.  28.  28.  28.]\n  [ 80.  80.  80.  80.  80.  80.]\n  [162. 162. 162. 162. 162. 162.]]]\n>>> # case 3: Reduces a dimension along axis 1.\n>>> output = ops.prod(x, 1, True)\n>>> print(output)\n[[[  6.   6.   6.   6.   6.   6.]]\n [[120. 120. 120. 120. 120. 120.]]\n [[504. 504. 504. 504. 504. 504.]]]\n>>> # case 4: Reduces a dimension along axis 2.\n>>> output = ops.prod(x, 2, True)\n>>> print(output)\n[[[1.00000e+00]\n  [6.40000e+01]\n  [7.29000e+02]]\n [[4.09600e+03]\n  [1.56250e+04]\n  [4.66560e+04]]\n [[1.17649e+05]\n  [2.62144e+05]\n  [5.31441e+05]]]\n"
  },
  {
    "name": "mindspore.ops.nansum",
    "signature": "mindspore.ops.nansum(input, axis=None, keepdims=False, *, dtype=None)",
    "description": "Computes sum of input over a given dimension, treating NaNs as zero.",
    "parameters": [
      "input (Tensor) – The input Tensor.",
      "axis (Union[int, tuple(int)], optional) – The dimensions to reduce. Supposed the rank of input is r, axis must be in the range [-rank(input), rank(input)). Default: None, all dimensions are reduced.",
      "keepdims (bool, optional) – Whether the output Tensor keeps dimensions or not. Default: False."
    ],
    "returns": "Tensor, the sum of input input in the given dimension dim, treating NaNs as zero. If axis is None, keepdims is False, the output is a 0-D Tensor representing the sum of all elements in the input Tensor. If axis is int, set as 2, and keepdims is False, the shape of output is \\((input_1, input_3, ..., input_R)\\). If axis is tuple(int) or list(int), set as (2, 3), and keepdims is False, the shape of output is \\((input_1, input_4, ..., input_R)\\).",
    "examples": "None\nFalse\nmindspore.dtype\nNone\n>>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> x = Tensor(np.array([[float(\"nan\"), 2, 3], [1, 2, float(\"nan\")]]), mindspore.float32)\n>>> output1 = ops.nansum(x, axis=0, keepdims=False, dtype=mindspore.float32)\n>>> output2 = ops.nansum(x, axis=0, keepdims=True, dtype=mindspore.float32)\n>>> print(output1)\n[1. 4. 3.]\n>>> print(output2)\n[[1. 4. 3.]]\n"
  },
  {
    "name": "mindspore.ops.std",
    "signature": "mindspore.ops.std(input, axis=None, ddof=0, keepdims=False)",
    "description": "Returns the standard-deviation of each row of the input Tensor by default, or it can calculate them in specified dimension axis. If axis is a list of dimensions, reduce over all of them.",
    "parameters": [
      "input (Tensor[Number]) – Input Tensor with a dtype of number.Number, its shape should be \\((N, *)\\) where \\(*\\) means any number of additional dims.",
      "axis (Union[int, tuple(int)], optional) – The dimensions to reduce. Only constant value is allowed. Must be in the range [-rank(input), rank(input)). Default: None , reduce all dimensions.",
      "ddof (Union[int, bool], optional) – Means Delta Degrees of Freedom. If ddof is an integer, the divisor used in calculations is \\(N - ddof\\), where \\(N\\) represents the number of elements. If ddof is True, will use the Bessel correction unbiased estimation. If ddof is False, will through the biased estimation to calculate the standard deviation. Default: 0 .",
      "keepdims (bool, optional) – Whether the output Tensor has dim retained or not. If true, keep these reduced dimensions and the length is 1. If false, don’t keep these dimensions. Default: False ."
    ],
    "returns": "Tensor, the standard deviation. Suppose the shape of input is \\((x_0, x_1, ..., x_R)\\): If axis is () and keepdims is set to False, returns a 0-D Tensor, indicating the standard deviation of all elements in input. If axis is int 1 and keepdims is set to False, then the returned Tensor has shape \\((x_0, x_2, ..., x_R)\\). If axis is tuple(int) or list(int), e.g. (1, 2) and keepdims is set to False, then the returned Tensor has shape \\((x_0, x_2, ..., x_R)\\).",
    "examples": "None\n0\nFalse\n>>> import mindspore as ms\n>>> input = ms.Tensor([[1, 2, 3, 4], [-1, 1, 4, -10]], ms.float32)\n>>> output = ms.ops.std(input, 1, 2, True)\n>>> print(output)\n[[1.5811388]\n [7.3824115]]\n"
  },
  {
    "name": "mindspore.ops.sum",
    "signature": "mindspore.ops.sum(input, dim=None, keepdim=False, *, dtype=None)",
    "description": "Calculate sum of Tensor elements over a given dim.",
    "parameters": [
      "input (Tensor) – The input tensor.",
      "dim (Union[None, int, tuple(int), list(int)]) – Dimensions along which a sum is performed. If None, sum all the elements of the input tensor. If the dim is a tuple or list of ints, a sum is performed on all the dimensions specified in the tuple. Must be in the range \\([-input.ndim, input.ndim)\\) . Default: None.",
      "keepdim (bool) – Whether the output tensor has dim retained or not. If True, keep these reduced dimensions and the length is 1. If False, don’t keep these dimensions. Default: False."
    ],
    "returns": "A Tensor, sum of elements over a given dim in input.",
    "examples": "None\nFalse\nmindspore.dtype\nNone\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> from mindspore import dtype as mstype\n>>> x = Tensor(np.array([[[1, 1, 1, 1, 1, 1], [2, 2, 2, 2, 2, 2], [3, 3, 3, 3, 3, 3]],\n...                      [[4, 4, 4, 4, 4, 4], [5, 5, 5, 5, 5, 5], [6, 6, 6, 6, 6, 6]],\n...                      [[7, 7, 7, 7, 7, 7], [8, 8, 8, 8, 8, 8], [9, 9, 9, 9, 9, 9]]]), mstype.float32)\n>>> out = ops.sum(x)\n>>> print(out)\n270.0\n>>> out = ops.sum(x, dim=2)\n>>> print(out)\n[[ 6. 12. 18.]\n [24. 30. 36.]\n [42. 48. 54.]]\n>>> out = ops.sum(x, dim=2, keepdim=True)\n>>> print(out)\n[[[ 6.]\n [12.]\n [18.]]\n[[24.]\n [30.]\n [36.]]\n[[42.]\n [48.]\n [54.]]]\n"
  },
  {
    "name": "mindspore.ops.logsumexp",
    "signature": "mindspore.ops.logsumexp(input, axis, keep_dims=False)",
    "description": "Reduces a dimension of a tensor by calculating exponential for all elements in the dimension, then calculate logarithm of the sum.",
    "parameters": [
      "input (Tensor) – The input tensor. With float16 or float32 data type.",
      "axis (Union[int, tuple(int), list(int)]) – The dimensions to reduce. Only constant value is allowed.",
      "keep_dims (bool) – If True, keep these reduced dimensions and the length is 1. If False , don’t keep these dimensions. Default : False ."
    ],
    "returns": "Tensor, has the same dtype as the input. If axis is (), and keep_dims is False, the output is a 0-D tensor representing the sum of all elements in the input tensor. If axis is int, set as 2, and keep_dims is False, the shape of output is \\((input_1, input_3, ..., input_R)\\). If axis is tuple(int), set as (2, 3), and keep_dims is False, the shape of output is \\((input_1, input_4, ..., input_R)\\).",
    "examples": "False\nFalse\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> x = Tensor(np.random.randn(3, 4, 5, 6).astype(np.float32))\n>>> output = ops.logsumexp(x, 1, keep_dims=True)\n>>> print(output.shape)\n(3, 1, 5, 6)\n"
  },
  {
    "name": "mindspore.ops.var",
    "signature": "mindspore.ops.var(input, axis=None, ddof=0, keepdims=False)",
    "description": "Returns the variance of each row of the input Tensor by default, or it can calculate them in specified dimension axis. If axis is a list of dimensions, reduce over all of them.",
    "parameters": [
      "input (Tensor[Number]) – Input Tensor with a dtype of number.Number, its shape should be \\((N, *)\\) where \\(*\\) means any number of additional dims.",
      "axis (Union[int, tuple(int)], optional) – The dimensions to reduce. Only constant value is allowed. Must be in the range [-rank(input), rank(input)). Default: None , reduce all dimensions.",
      "ddof (Union[int, bool], optional) – Means Delta Degrees of Freedom. If ddof is an integer, the divisor used in calculations is \\(N - ddof\\), where \\(N\\) represents the number of elements. If ddof is True, will use the Bessel correction unbiased estimation. If ddof is False, will through the biased estimation to calculate variance. Default: 0 .",
      "keepdims (bool, optional) – Whether the output Tensor has dim retained or not. If true , keep these reduced dimensions and the length is 1. If false, don’t keep these dimensions. Default: False ."
    ],
    "returns": "Tensor, the variance. Suppose the shape of input is \\((x_0, x_1, ..., x_R)\\): If axis is () and keepdims is set to False , returns a 0-D Tensor, indicating the standard deviation of all elements in input. If axis is int 1 and keepdims is set to False , then the returned Tensor has shape \\((x_0, x_2, ..., x_R)\\). If axis is tuple(int) or list(int), e.g. (1, 2) and keepdims is set to False , then the returned Tensor has shape \\((x_0, x_2, ..., x_R)\\).",
    "examples": "None\n0\ntrue\nFalse\nFalse\nFalse\nFalse\n>>> import mindspore as ms\n>>> input = ms.Tensor([[1, 2, 3, 4], [-1, 1, 4, -10]], ms.float32)\n>>> output = ms.ops.var(input, 1, 2, True)\n>>> print(output)\n[[ 2.5]\n [54.5]]\n"
  },
  {
    "name": "mindspore.ops.all",
    "signature": "mindspore.ops.all(input, axis=None, keep_dims=False)",
    "description": "Reduces a dimension of input by the “logical AND” of all elements in the dimension, by default. And also can reduce a dimension of input along the axis. Determine whether the dimensions of the output and input are the same by controlling keep_dims.",
    "parameters": [
      "input (Tensor) – Input Tensor, has the shape \\((N, *)\\) where \\(*\\) means, any number of additional dimensions.",
      "axis (Union[int, tuple(int), list(int)], optional) – The dimensions to reduce. Suppose the rank of input is r, axis must be in the range [-rank(input), rank(input)). Default: None , all dimensions are reduced.",
      "keep_dims (bool, optional) – If true, keep these reduced dimensions and the length is 1. If false, don’t keep these dimensions. Default : False ."
    ],
    "returns": "Tensor, the dtype is bool. If axis is None, and keep_dims is False , the output is a 0-D Tensor representing the “logical AND” of all elements in the input Tensor. If axis is int, such as 2, and keep_dims is False , the shape of output is \\((input_1, input_3, ..., input_R)\\). If axis is tuple(int), such as (2, 3), and keep_dims is False, the shape of output is \\((input_1, input_4, ..., input_R)\\).",
    "examples": "None\nFalse\nFalse\nFalse\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> x = Tensor(np.array([[True, False], [True, True]]))\n>>> # case 1: Reduces a dimension by the \"logicalAND\" of all elements in the dimension.\n>>> output = ops.all(x, keep_dims=True)\n>>> print(output)\n[[False]]\n>>> print(output.shape)\n(1, 1)\n>>> # case 2: Reduces a dimension along axis 0.\n>>> output = ops.all(x, axis=0)\n>>> print(output)\n[ True False]\n>>> # case 3: Reduces a dimension along axis 1.\n>>> output = ops.all(x, axis=1)\n>>> print(output)\n[False True]\n"
  },
  {
    "name": "mindspore.ops.argsort",
    "signature": "mindspore.ops.argsort(input, axis=- 1, descending=False)",
    "description": "Sorts the input tensor along the given dimension in specified order and return the sorted indices.",
    "parameters": [
      "input (Tensor) – The input tensor to sort.",
      "axis (int) – The axis to sort along. Default: -1 , means the last dimension. The Ascend backend only supports sorting the last dimension.",
      "descending (bool) – The sort order. If descending is True then the elements are sorted in descending order by value. Otherwise sort in ascending order. Default: False ."
    ],
    "returns": "Tensor, the indices of sorted input tensor. Data type is int32.",
    "examples": "-1\nFalse\n>>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> x = Tensor(np.array([[8, 2, 1], [5, 9, 3], [4, 6, 7]]), mindspore.float16)\n>>> sort = ops.argsort(x)\n>>> print(sort)\n[[2 1 0]\n [2 0 1]\n [0 1 2]]\n"
  },
  {
    "name": "mindspore.ops.equal",
    "signature": "mindspore.ops.equal(input, other)",
    "description": "Computes the equivalence between two tensors element-wise.",
    "parameters": [
      "input (Union[Tensor, Number]) – The first input is a number or a tensor whose data type is number.query.dtye",
      "other (Union[Tensor, Number]) – The second input is a number when the first input is a tensor. The data type is the same as the first input. If the first input is a number, the second input should be a tensor."
    ],
    "returns": "Tensor, the shape is the same as the one after broadcasting, and the data type is bool.",
    "examples": ">>> import mindspore\n>>> from mindspore import Tensor, ops\n>>> # case 1: The shape of two inputs are different\n>>> x = Tensor([1, 2, 3], mindspore.float32)\n>>> output = ops.equal(x, 2.0)\n>>> print(output)\n[False True False]\n>>> # case 2: The shape of two inputs are the same\n>>> x = Tensor([1, 2, 3], mindspore.int32)\n>>> y = Tensor([1, 2, 4], mindspore.int32)\n>>> output = ops.equal(x, y)\n>>> print(output)\n[ True  True False]\n"
  },
  {
    "name": "mindspore.ops.gt",
    "signature": "mindspore.ops.gt(input, other)",
    "description": "Compare the value of the input parameters \\(input,other\\) element-wise, and the output result is a bool value.",
    "parameters": [
      "input (Union[Tensor, number.Number, bool]) – The first input is a number.Number or a bool or a tensor whose data type is number or bool_ .",
      "other (Union[Tensor, number.Number, bool]) – The second input, when the first input is a Tensor, the second input should be a number.Number or bool value, or a Tensor whose data type is number or bool_. When the first input is Scalar, the second input must be a Tensor whose data type is number or bool_."
    ],
    "returns": "Tensor, the shape is the same as the one after broadcasting, and the data type is bool.",
    "examples": ">>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> x = Tensor(np.array([1, 2, 3]), mindspore.int32)\n>>> y = Tensor(np.array([1, 1, 4]), mindspore.int32)\n>>> output = ops.gt(x, y)\n>>> print(output)\n[False True False]\n"
  },
  {
    "name": "mindspore.ops.isinf",
    "signature": "mindspore.ops.isinf(input)",
    "description": "Determines which elements are inf or -inf for each position.",
    "parameters": [
      "input (Tensor) – The input tensor."
    ],
    "returns": "Tensor, has the same shape of input, and the dtype is bool.",
    "examples": ">>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> x = Tensor(np.array([np.log(-1), 1, np.log(0)]), mindspore.float32)\n>>> output = ops.isinf(x)\n>>> print(output)\n[False False True]\n>>> x = Tensor(2.1, mindspore.float64)\n>>> output = ops.isinf(x)\n>>> print(output)\nFalse\n"
  },
  {
    "name": "mindspore.ops.isnan",
    "signature": "mindspore.ops.isnan(input)",
    "description": "Determines which elements are NaN for each position.",
    "parameters": [
      "input (Tensor) – The input tensor."
    ],
    "returns": "Tensor, has the same shape of input, and the dtype is bool.",
    "examples": ">>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> x = Tensor(np.array([np.log(-1), 1, np.log(0)]), mindspore.float32)\n>>> output = ops.isnan(x)\n>>> print(output)\n[ True False False]\n>>> x = Tensor(2.1, mindspore.float64)\n>>> output = ops.isnan(x)\n>>> print(output)\nFalse\n"
  },
  {
    "name": "mindspore.ops.le",
    "signature": "mindspore.ops.le(input, other)",
    "description": "Computes the boolean value of \\(input <= other\\) element-wise.",
    "parameters": [
      "input (Union[Tensor, number.Number, bool]) – The first input is a number.Number or a bool or a tensor whose data type is number or bool_.",
      "other (Union[Tensor, number.Number, bool]) – The second input, when the first input is a Tensor, the second input should be a number.Number or bool value, or a Tensor whose data type is number or bool_. When the first input is Scalar, the second input must be a Tensor whose data type is number or bool_."
    ],
    "returns": "Tensor, the shape is the same as the one after broadcasting, and the data type is bool.",
    "examples": ">>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> x = Tensor(np.array([1, 2, 3]), mindspore.int32)\n>>> y = Tensor(np.array([1, 1, 4]), mindspore.int32)\n>>> output = ops.le(x, y)\n>>> print(output)\n[ True False  True]\n"
  },
  {
    "name": "mindspore.ops.lt",
    "signature": "mindspore.ops.lt(input, other)",
    "description": "Alias for mindspore.ops.less() .",
    "parameters": [],
    "returns": "",
    "examples": ""
  },
  {
    "name": "mindspore.ops.ne",
    "signature": "mindspore.ops.ne(input, other)",
    "description": "Computes the non-equivalence of two tensors element-wise.",
    "parameters": [
      "input (Union[Tensor, Number, bool]) – The first input is a number or a bool or a tensor whose data type is number or bool.",
      "other (Union[Tensor, Number, bool]) – The second input is a number or a bool when the first input is a tensor or a tensor whose data type is number or bool."
    ],
    "returns": "Tensor, the shape is the same as the one after broadcasting,and the data type is bool.",
    "examples": ">>> import mindspore\n>>> from mindspore import Tensor, ops\n>>> x = Tensor([1, 2, 3], mindspore.float32)\n>>> output = ops.ne(x, 2.0)\n>>> print(output)\n[ True False  True]\n>>>\n>>> x = Tensor([1, 2, 3], mindspore.int32)\n>>> y = Tensor([1, 2, 4], mindspore.int32)\n>>> output = ops.ne(x, y)\n>>> print(output)\n[False False  True]\n"
  },
  {
    "name": "mindspore.ops.sort",
    "signature": "mindspore.ops.sort(input_x, axis=- 1, descending=False)",
    "description": "Sorts the elements of the input tensor along the given dimension in the specified order.",
    "parameters": [
      "input_x (Tensor) – The input tensor to sort. The shape is \\((N,*)\\) where \\(*\\) means, any number of additional dimensions.",
      "axis (int, optional) – The dimension to sort along. Default: -1, means the last dimension. The Ascend backend only supports sorting the last dimension.",
      "descending (bool, optional) – Controls the sort order. If descending is True, the elements are sorted in descending order, or else sorted in ascending order. Default: False ."
    ],
    "returns": "",
    "examples": "-1\nFalse\n>>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> x = Tensor(np.array([[8, 2, 1], [5, 9, 3], [4, 6, 7]]), mindspore.float16)\n>>> output = ops.sort(x)\n>>> # The output below is based on the platform.\n>>> print(output)\n(Tensor(shape=[3, 3], dtype=Float16, value=\n[[ 1.0000e+00,  2.0000e+00,  8.0000e+00],\n[ 3.0000e+00,  5.0000e+00,  9.0000e+00],\n[ 4.0000e+00,  6.0000e+00,  7.0000e+00]]), Tensor(shape=[3, 3], dtype=Int32, value=\n[[2, 1, 0],\n[2, 0, 1],\n[0, 1, 2]]))\n"
  },
  {
    "name": "mindspore.ops.topk",
    "signature": "mindspore.ops.topk(input, k, dim=None, largest=True, sorted=True)",
    "description": "Finds values and indices of the k largest or smallest entries along a given dimension.",
    "parameters": [
      "input (Tensor) – Input to be computed, data type must be float16, float32 or int32.",
      "k (int) – The number of top or bottom elements to be computed along the last dimension, constant input is needed.",
      "dim (int, optional) – The dimension to sort along. Default: None .",
      "largest (bool, optional) – If largest is False then the k smallest elements are returned. Default: True .",
      "sorted (bool, optional) – If True , the obtained elements will be sorted by the values in descending order. If False , the obtained elements will not be sorted. Default: True ."
    ],
    "returns": "A tuple consisting of values and indexes. values (Tensor): The k largest or smallest elements in each slice of the given dimension. indices (Tensor): The indices of values within the last dimension of input.",
    "examples": "None\nFalse\nTrue\nTrue\nFalse\nTrue\n>>> import mindspore as ms\n>>> from mindspore import ops\n>>> x = ms.Tensor([[0.5368, 0.2447, 0.4302, 0.9673],\n...                [0.4388, 0.6525, 0.4685, 0.1868],\n...                [0.3563, 0.5152, 0.9675, 0.8230]], dtype=ms.float32)\n>>> output = ops.topk(x, 2, dim=1)\n>>> print(output)\n(Tensor(shape=[3, 2], dtype=Float32, value=\n[[ 9.67299998e-01,  5.36800027e-01],\n [ 6.52499974e-01,  4.68499988e-01],\n [ 9.67499971e-01,  8.23000014e-01]]), Tensor(shape=[3, 2], dtype=Int32, value=\n[[3, 0],\n [1, 2],\n [2, 3]]))\n>>> output2 = ops.topk(x, 2, dim=1, largest=False)\n>>> print(output2)\n(Tensor(shape=[3, 2], dtype=Float32, value=\n[[ 2.44700000e-01,  4.30200011e-01],\n [ 1.86800003e-01,  4.38800007e-01],\n [ 3.56299996e-01,  5.15200019e-01]]), Tensor(shape=[3, 2], dtype=Int32, value=\n[[1, 2],\n [3, 0],\n [0, 1]]))\n"
  },
  {
    "name": "mindspore.ops.ge",
    "signature": "mindspore.ops.ge(input, other)",
    "description": "Computes the boolean value of \\(input >= other\\) element-wise.",
    "parameters": [
      "input (Union[Tensor, Number, bool]) – The first input is a number or a bool or a tensor whose data type is number or bool.",
      "other (Union[Tensor, Number, bool]) – The second input is a number or a bool when the first input is a tensor or a tensor whose data type is number or bool."
    ],
    "returns": "Tensor, the shape is the same as the one after broadcasting, and the data type is bool.",
    "examples": ">>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> x = Tensor(np.array([1, 2, 3]), mindspore.int32)\n>>> y = Tensor(np.array([1, 1, 4]), mindspore.int32)\n>>> output = ops.ge(x, y)\n>>> print(output)\n[True True False]\n"
  },
  {
    "name": "mindspore.ops.greater",
    "signature": "mindspore.ops.greater(input, other)",
    "description": "Computes the boolean value of \\(input > other\\) element-wise.",
    "parameters": [
      "input (Union[Tensor, number.Number, bool]) – The first input is a number.Number or a bool or a tensor whose data type is number or bool_ .",
      "other (Union[Tensor, number.Number, bool]) – The second input, when the first input is a Tensor, the second input should be a number.Number or bool value, or a Tensor whose data type is number or bool_. When the first input is Scalar, the second input must be a Tensor whose data type is number or bool_."
    ],
    "returns": "Tensor, the shape is the same as the one after broadcasting, and the data type is bool.",
    "examples": ">>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> x = Tensor(np.array([1, 2, 3]), mindspore.int32)\n>>> y = Tensor(np.array([1, 1, 4]), mindspore.int32)\n>>> output = ops.greater(x, y)\n>>> print(output)\n[False True False]\n"
  },
  {
    "name": "mindspore.ops.greater_equal",
    "signature": "mindspore.ops.greater_equal(input, other)",
    "description": "Computes the boolean value of \\(input \\geq other\\) element-wise.",
    "parameters": [
      "input (Union[Tensor, number.Number, bool]) – The first input is a number.Number or a bool or a tensor whose data type is number or bool_ .",
      "other (Union[Tensor, number.Number, bool]) – The second input, when the first input is a Tensor, the second input should be a number.Number or bool value, or a Tensor whose data type is number or bool_. When the first input is Scalar, the second input must be a Tensor whose data type is number or bool_."
    ],
    "returns": "Tensor, the shape is the same as the one after broadcasting, and the data type is bool.",
    "examples": ">>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> x = Tensor(np.array([1, 2, 3]), mindspore.int32)\n>>> y = Tensor(np.array([1, 1, 4]), mindspore.int32)\n>>> output = ops.greater_equal(x, y)\n>>> print(output)\n[True True False]\n"
  },
  {
    "name": "mindspore.ops.maximum",
    "signature": "mindspore.ops.maximum(input, other)",
    "description": "Computes the maximum of input tensors element-wise.",
    "parameters": [
      "input (Union[Tensor, Number, bool]) – The first input is a number or a bool or a tensor whose data type is number or bool.",
      "other (Union[Tensor, Number, bool]) – The second input is a number or a bool when the first input is a tensor or a tensor whose data type is number or bool."
    ],
    "returns": "Tensor, the shape is the same as the one after broadcasting, and the data type is the one with higher precision or higher digits among the two inputs.",
    "examples": ">>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> # case 1 : same data type\n>>> x = Tensor(np.array([1.0, 5.0, 3.0]), mindspore.float32)\n>>> y = Tensor(np.array([4.0, 2.0, 6.0]), mindspore.float32)\n>>> output = ops.maximum(x, y)\n>>> print(output)\n[4. 5. 6.]\n>>> # case 2 : different data type\n>>> x = Tensor(np.array([1.0, 5.0, 3.0]), mindspore.int32)\n>>> y = Tensor(np.array([4.0, 2.0, 6.0]), mindspore.float32)\n>>> output = ops.maximum(x, y)\n>>> print(output.dtype)\nFloat32\n"
  },
  {
    "name": "mindspore.ops.minimum",
    "signature": "mindspore.ops.minimum(input, other)",
    "description": "Computes the minimum of input tensors element-wise.",
    "parameters": [
      "input (Union[Tensor, Number, bool]) – The first input is a number or a bool or a tensor whose data type is number or bool.",
      "other (Union[Tensor, Number, bool]) – The second input is a number or a bool when the first input is a tensor or a tensor whose data type is number or bool."
    ],
    "returns": "Tensor, the shape is the same as the one after broadcasting, and the data type is the one with higher precision or higher digits among the two inputs.",
    "examples": ">>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> # case 1 : same data type\n>>> x = Tensor(np.array([1.0, 5.0, 3.0]), mindspore.float32)\n>>> y = Tensor(np.array([4.0, 2.0, 6.0]), mindspore.float32)\n>>> output = ops.minimum(x, y)\n>>> print(output)\n[1. 2. 3.]\n>>> # case 2 : different data type\n>>> x = Tensor(np.array([1.0, 5.0, 3.0]), mindspore.int32)\n>>> y = Tensor(np.array([4.0, 2.0, 6.0]), mindspore.float32)\n>>> output = ops.minimum(x, y)\n>>> print(output.dtype)\nFloat32\n"
  },
  {
    "name": "mindspore.ops.not_equal",
    "signature": "mindspore.ops.not_equal(input, other)",
    "description": "Alias for mindspore.ops.ne() .",
    "parameters": [],
    "returns": "",
    "examples": ""
  },
  {
    "name": "mindspore.ops.isclose",
    "signature": "mindspore.ops.isclose(input, other, rtol=1e-05, atol=1e-08, equal_nan=False)",
    "description": "Returns a new Tensor with boolean elements representing if each element of input is “close” to the corresponding element of other. Closeness is defined as:",
    "parameters": [
      "input (Tensor) – First Tensor to compare, with data type belongs to float32, float16, int32.",
      "other (Tensor) – Second Tensor to compare, with data type belongs to float32, float16, int32.",
      "rtol (float, optional) – Relative tolerance. Default: 1e-05 .",
      "atol (float, optional) – Absolute tolerance. Default: 1e-08 .",
      "equal_nan (bool, optional) – If True, then two NaNs will be considered equal. Default: False ."
    ],
    "returns": "A bool Tensor, with the shape as broadcasted result of the input input and other.",
    "examples": "1e-05\n1e-08\nFalse\n>>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> input = Tensor(np.array([1.3, 2.1, 3.2, 4.1, 5.1]), mindspore.float16)\n>>> other = Tensor(np.array([1.3, 3.3, 2.3, 3.1, 5.1]), mindspore.float16)\n>>> output = ops.isclose(input, other)\n>>> print(output)\n[ True False False False  True]\n"
  },
  {
    "name": "mindspore.ops.cumprod",
    "signature": "mindspore.ops.cumprod(input, dim, dtype=None)",
    "description": "Computes the cumulative product of the input tensor along dimension dim. For example, if input is a vector of size N, the result will also be a vector of size N, with elements.",
    "parameters": [
      "input (Tensor[Number]) – The input tensor. \\((N,*)\\) where \\(*\\) means, any number of additional dimensions.",
      "dim (int) – The dimensions to compute the cumulative product. Only constant value is allowed.",
      "dtype (mindspore.dtype, optional) – The desired data type of output. If not specified, remains the same as the original Tensor. Default: None ."
    ],
    "returns": "Tensor, has the same shape and dtype as the input unless dtype is specified.",
    "examples": "mindspore.dtype\nNone\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> x = Tensor(np.array([1, 2, 3], np.float32))\n>>> output = ops.cumprod(x, 0)\n>>> print(output)\n[1. 2. 6.]\n"
  },
  {
    "name": "mindspore.ops.cumsum",
    "signature": "mindspore.ops.cumsum(x, axis, dtype=None)",
    "description": "Computes the cumulative sum of input Tensor along axis.",
    "parameters": [
      "x (Tensor) – The input Tensor of shape \\((N,*)\\) where \\(*\\) means, any number of additional dimensions.",
      "axis (int) – Axis along which the cumulative sum is computed.",
      "dtype (mindspore.dtype, optional) – The desired dtype of returned Tensor. If specified, the input Tensor will be cast to dtype before the computation. This is useful for preventing overflows. If not specified, stay the same as original Tensor. Default: None ."
    ],
    "returns": "Tensor, the shape of the output Tensor is consistent with the input Tensor’s.",
    "examples": "mindspore.dtype\nNone\n>>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor\n>>> import mindspore.ops as ops\n>>> x = Tensor(np.array([[3, 4, 6, 10], [1, 6, 7, 9], [4, 3, 8, 7], [1, 3, 7, 9]]).astype(np.float32))\n>>> # case 1: along the axis 0\n>>> y = ops.cumsum(x, 0)\n>>> print(y)\n[[ 3.  4.  6. 10.]\n [ 4. 10. 13. 19.]\n [ 8. 13. 21. 26.]\n [ 9. 16. 28. 35.]]\n>>> # case 2: along the axis 1\n>>> y = ops.cumsum(x, 1)\n>>> print(y)\n[[ 3.  7. 13. 23.]\n [ 1.  7. 14. 23.]\n [ 4.  7. 15. 22.]\n [ 1.  4. 11. 20.]]\n"
  },
  {
    "name": "mindspore.ops.diagonal",
    "signature": "mindspore.ops.diagonal(input, offset=0, dim1=0, dim2=1)",
    "description": "Returns specified diagonals of input.",
    "parameters": [
      "input (Tensor) – Array from which the diagonals are taken.",
      "offset (int, optional) – Offset of the diagonal from the main diagonal. Can be positive or negative. Default: 0 .",
      "dim1 (int, optional) – Axis to be used as the first axis of the 2-D sub-arrays from which the diagonals should be taken. Defaults to first axis (0). Default: 0 .",
      "dim2 (int, optional) – Axis to be used as the second axis of the 2-D sub-arrays from which the diagonals should be taken. Defaults to second axis (1). Default: 1 ."
    ],
    "returns": "Tensor, if input is 2-D, then input 1-D array containing the diagonal. If input.ndim > 2, then the dimensions specified by dim1 and dim2 are removed, and a new axis inserted at the end corresponding to the diagonal.",
    "examples": "0\n0\n1\ninput.ndim > 2\n>>> from mindspore import Tensor, ops\n>>> from mindspore import dtype as mstype\n>>> x = Tensor([[0, 1], [2, 3]], mstype.float32)\n>>> output = ops.diagonal(x)\n>>> print(output)\n[0 3]\n"
  },
  {
    "name": "mindspore.ops.flatten",
    "signature": "mindspore.ops.flatten(input, order='C', *, start_dim=1, end_dim=- 1)",
    "description": "Flatten a tensor along dimensions from start_dim to start_dim.",
    "parameters": [
      "input (Tensor) – The input Tensor.",
      "order (str, optional) – Only 'C' and 'F' are supported. 'C' means to flatten in row-major (C-style) order. 'F' means to flatten in column-major (Fortran-style) order. Default: 'C' ."
    ],
    "returns": "Tensor. If no dimensions are flattened, returns the original input, otherwise return the flattened Tensor. If input is a 0-dimensional Tensor, a 1-dimensional Tensor will be returned.",
    "examples": "'C'\n'F'\n'C'\n'F'\n'C'\n1\n-1\n>>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> input_x = Tensor(np.ones(shape=[1, 2, 3, 4]), mindspore.float32)\n>>> output = ops.flatten(input_x)\n>>> print(output.shape)\n(1, 24)\n"
  },
  {
    "name": "mindspore.ops.flip",
    "signature": "mindspore.ops.flip(input, dims)",
    "description": "Reverses the order of elements in a tensor along the given axis.",
    "parameters": [
      "input (Tensor) – Input tensor.",
      "dims (Union[list[int], tuple[int]]) – Axis or axes along which to flip over. Flipping is performed on all of the axes specified in the tuple, If dims is a tuple of integers contains negative, it counts from the last to the first axis."
    ],
    "returns": "Tensor, with the entries of dims reversed.",
    "examples": ">>> import mindspore as ms\n>>> import mindspore.ops as ops\n>>> import numpy as np\n>>> input = ms.Tensor(np.arange(1, 9).reshape((2, 2, 2)))\n>>> output = ops.flip(input, (0, 2))\n>>> print(output)\n[[[6 5]\n  [8 7]]\n [[2 1]\n  [4 3]]]\n"
  },
  {
    "name": "mindspore.ops.meshgrid",
    "signature": "mindspore.ops.meshgrid(*inputs, indexing='xy')",
    "description": "Generates coordinate matrices from given coordinate tensors.",
    "parameters": [
      "inputs (List[Tensor]) – List of 1-D tensors. The length of inputs should be greater than 1. The data type is Number."
    ],
    "returns": "Tensors, a Tuple of N N-D Tensor objects. The data type is the same with the Inputs.",
    "examples": "'xy'\n>>> import numpy as np\n>>> from mindspore import Tensor\n>>> import mindspore.ops as ops\n>>> x = Tensor(np.array([1, 2, 3, 4]).astype(np.int32))\n>>> y = Tensor(np.array([5, 6, 7]).astype(np.int32))\n>>> z = Tensor(np.array([8, 9, 0, 1, 2]).astype(np.int32))\n>>> output = ops.meshgrid(x, y, z, indexing='xy')\n>>> print(output)\n(Tensor(shape=[3, 4, 5], dtype=Int32, value=\n [[[1, 1, 1, 1, 1],\n   [2, 2, 2, 2, 2],\n   [3, 3, 3, 3, 3],\n   [4, 4, 4, 4, 4]],\n  [[1, 1, 1, 1, 1],\n   [2, 2, 2, 2, 2],\n   [3, 3, 3, 3, 3],\n   [4, 4, 4, 4, 4]],\n  [[1, 1, 1, 1, 1],\n   [2, 2, 2, 2, 2],\n   [3, 3, 3, 3, 3],\n   [4, 4, 4, 4, 4]]]),\n Tensor(shape=[3, 4, 5], dtype=Int32, value=\n [[[5, 5, 5, 5, 5],\n   [5, 5, 5, 5, 5],\n   [5, 5, 5, 5, 5],\n   [5, 5, 5, 5, 5]],\n  [[6, 6, 6, 6, 6],\n   [6, 6, 6, 6, 6],\n   [6, 6, 6, 6, 6],\n   [6, 6, 6, 6, 6]],\n  [[7, 7, 7, 7, 7],\n   [7, 7, 7, 7, 7],\n   [7, 7, 7, 7, 7],\n   [7, 7, 7, 7, 7]]]),\n Tensor(shape=[3, 4, 5], dtype=Int32, value=\n [[[8, 9, 0, 1, 2],\n   [8, 9, 0, 1, 2],\n   [8, 9, 0, 1, 2],\n   [8, 9, 0, 1, 2]],\n  [[8, 9, 0, 1, 2],\n   [8, 9, 0, 1, 2],\n   [8, 9, 0, 1, 2],\n   [8, 9, 0, 1, 2]],\n  [[8, 9, 0, 1, 2],\n   [8, 9, 0, 1, 2],\n   [8, 9, 0, 1, 2],\n   [8, 9, 0, 1, 2]]]))\n"
  },
  {
    "name": "mindspore.ops.roll",
    "signature": "mindspore.ops.roll(input, shifts, dims=None)",
    "description": "Rolls the elements of a tensor along an axis.",
    "parameters": [
      "input (Tensor) – Input tensor.",
      "shifts (Union[list(int), tuple(int), int]) – Specifies the number of places by which elements are shifted positively (towards larger indices) along the specified dimension. Negative shifts will roll the elements in the opposite direction.",
      "dims (Union[list(int), tuple(int), int], optional) – Specifies the dimension indexes of shape to be rolled. Default: None. If dims is None, the Tensor will be flattened before rolling and then restored to the original shape."
    ],
    "returns": "Tensor, has the same shape and type as input.",
    "examples": "None\n>>> import numpy as np\n>>> import mindspore as ms\n>>> import mindspore.ops as ops\n>>> from mindspore import Tensor\n>>> input_x = Tensor(np.array([0, 1, 2, 3, 4]).astype(np.float32))\n>>> output = ops.roll(input_x, shifts=2, dims=0)\n>>> print(output)\n[3. 4. 0. 1. 2.]\n"
  },
  {
    "name": "mindspore.ops.tril",
    "signature": "mindspore.ops.tril(input, diagonal=0)",
    "description": "Returns the lower triangle part of ‘input’ (elements that contain the diagonal and below), and set the other elements to zeros.",
    "parameters": [
      "input (Tensor) – A Tensor with shape \\((x_1, x_2, ..., x_R)\\). The rank must be at least 2. Supporting all number types including bool.",
      "diagonal (int, optional) – An optional attribute indicates the diagonal to consider, default: 0, indicating the main diagonal."
    ],
    "returns": "Tensor, the same shape and data type as the input x.",
    "examples": ">>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> x = Tensor(np.array([[ 1,  2,  3,  4],\n...                      [ 5,  6,  7,  8],\n...                      [10, 11, 12, 13],\n...                      [14, 15, 16, 17]]))\n>>> result = ops.tril(x)\n>>> print(result)\n[[ 1  0  0  0]\n [ 5  6  0  0]\n [10 11 12  0]\n [14 15 16 17]]\n>>> x = Tensor(np.array([[ 1,  2,  3,  4],\n...                      [ 5,  6,  7,  8],\n...                      [10, 11, 12, 13],\n...                      [14, 15, 16, 17]]))\n>>> result = ops.tril(x, diagonal=1)\n>>> print(result)\n[[ 1  2  0  0]\n [ 5  6  7  0]\n [10 11 12 13]\n [14 15 16 17]]\n>>> x = Tensor(np.array([[ 1,  2,  3,  4],\n...                      [ 5,  6,  7,  8],\n...                      [10, 11, 12, 13],\n...                      [14, 15, 16, 17]]))\n>>> result = ops.tril(x, diagonal=-1)\n>>> print(result)\n[[ 0  0  0  0]\n [ 5  0  0  0]\n [10 11  0  0]\n [14 15 16  0]]\n"
  },
  {
    "name": "mindspore.ops.triu",
    "signature": "mindspore.ops.triu(input, diagonal=0)",
    "description": "Returns the upper triangle part of ‘input’ (elements that contain the diagonal and below), and set the other elements to zeros.",
    "parameters": [
      "input (Tensor) – The input tensor with shape \\((M, N, *)\\) where * means any number of additional dimensions.",
      "diagonal (int, optional) – An optional attribute indicates the diagonal to consider, default: 0, indicating the main diagonal."
    ],
    "returns": "Tensor, a tensor has the same shape and data type as input.",
    "examples": ">>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> x = Tensor(np.array([[ 1,  2,  3,  4],\n...                      [ 5,  6,  7,  8],\n...                      [10, 11, 12, 13],\n...                      [14, 15, 16, 17]]))\n>>> result = ops.triu(x)\n>>> print(result)\n[[ 1  2  3  4]\n [ 0  6  7  8]\n [ 0  0 12 13]\n [ 0  0  0 17]]\n>>> x = Tensor(np.array([[ 1,  2,  3,  4],\n...                      [ 5,  6,  7,  8],\n...                      [10, 11, 12, 13],\n...                      [14, 15, 16, 17]]))\n>>> result = ops.triu(x, diagonal=1)\n>>> print(result)\n[[ 0  2  3  4]\n [ 0  0  7  8]\n [ 0  0  0 13]\n [ 0  0  0  0]]\n>>> x = Tensor(np.array([[ 1,  2,  3,  4],\n...                      [ 5,  6,  7,  8],\n...                      [10, 11, 12, 13],\n...                      [14, 15, 16, 17]]))\n>>> result = ops.triu(x, diagonal=-1)\n>>> print(result)\n[[ 1  2  3  4]\n [ 5  6  7  8]\n [ 0 11 12 13]\n [ 0  0 16 17]]\n"
  },
  {
    "name": "mindspore.ops.cross",
    "signature": "mindspore.ops.cross(input, other, dim=None)",
    "description": "Computes the cross product of input and other in dimension dim. input and other must have the same shape, and the size of their dim dimension should be 3. If dim is not specified, it is set to be the first dimension found with the size 3.",
    "parameters": [
      "input (Tensor) – input is a tensor.",
      "other (Tensor) – The other Tensor, other must have the same shape and type as input input, and the size of their dim dimension should be 3.",
      "dim (int, optional) – dimension to apply cross product in. if dim is None, it is set to be the first dimension found with the size 3. Default: None."
    ],
    "returns": "Tensor, has the same shape and type as input input.",
    "examples": "None\n>>> from mindspore import Tensor, ops\n>>> # case 1: dim=None.\n>>> x = Tensor([[1, 2, 3], [1, 2, 3]])\n>>> other = Tensor([[4, 5, 6], [4, 5, 6]])\n>>> output = ops.cross(x, other)\n>>> print(output)\n[[-3  6 -3]\n [-3  6 -3]]\n>>> # case 2: dim=1.\n>>> x = Tensor([[1, 2, 3], [1, 2, 3]])\n>>> other = Tensor([[4, 5, 6], [4, 5, 6]])\n>>> output = ops.cross(x, other, dim=1)\n>>> print(output)\n[[-3  6 -3]\n [-3  6 -3]]\n"
  },
  {
    "name": "mindspore.ops.bincount",
    "signature": "mindspore.ops.bincount(input, weights=None, minlength=0)",
    "description": "Counts the number of occurrences of each value in input.",
    "parameters": [
      "input (Tensor) – 1-d input tensor.",
      "weights (Tensor, optional) – Weights, a tensor of the same shape as input. Default: None .",
      "minlength (int, optional) – A minimum number of bins for the output tensor. Default: 0 ."
    ],
    "returns": "Tensor, a tensor of shape [max(input)+1] if input is non-empty, otherwise, the shape is [0].",
    "examples": "out[n] += weight[i]\nout[n] += 1\nNone\n0\n>>> from mindspore import Tensor, ops\n>>> from mindspore import dtype as mstype\n>>> x = Tensor([2, 4, 1, 0, 0], dtype=mstype.int64)\n>>> print(ops.bincount(x, minlength=7))\n[2. 1. 1. 0. 1. 0. 0.]\n>>> weights = Tensor([0, 0.25, 0.5, 0.75, 1], dtype=mstype.float32)\n>>> print(ops.bincount(x, weights=weights))\n[1.75 0.5  0.   0.   0.25]\n"
  },
  {
    "name": "mindspore.ops.unique",
    "signature": "mindspore.ops.unique(input)",
    "description": "Returns the unique elements of input tensor and also return a tensor containing the index of each value of input tensor corresponding to the output unique tensor.",
    "parameters": [
      "input (Tensor) – The input tensor. The shape is \\((N,*)\\) where \\(*\\) means, any number of additional dimensions."
    ],
    "returns": "the unique elements of input tensor and also return a tensor containing the index of each value of input tensor corresponding to the output unique tensor.",
    "examples": "mindspore.ops.UniqueWithPad\n>>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, nn\n>>> from mindspore import ops\n>>> x = Tensor(np.array([1, 2, 5, 2]), mindspore.int32)\n>>> output = ops.unique(x)\n>>> print(output)\n(Tensor(shape=[3], dtype=Int32, value= [1, 2, 5]), Tensor(shape=[4], dtype=Int32, value= [0, 1, 2, 1]))\n>>> y = output[0]\n>>> print(y)\n[1 2 5]\n>>> idx = output[1]\n>>> print(idx)\n[0 1 2 1]\n"
  },
  {
    "name": "mindspore.ops.dot",
    "signature": "mindspore.ops.dot(input, other)",
    "description": "Computation a dot product between samples in two tensors.",
    "parameters": [
      "input (Tensor) – First tensor in Dot op with datatype float16 or float32. The rank must be greater than or equal to 2.",
      "other (Tensor) – Second tensor in Dot op with datatype float16 or float32. The rank must be greater than or equal to 2."
    ],
    "returns": "Tensor, dot product of input and other.",
    "examples": ">>> import numpy as np\n>>> import mindspore\n>>> from mindspore import Tensor, ops\n>>> input = Tensor(np.ones(shape=[2, 3]), mindspore.float32)\n>>> other = Tensor(np.ones(shape=[1, 3, 2]), mindspore.float32)\n>>> output = ops.dot(input, other)\n>>> print(output)\n[[[3. 3.]]\n [[3. 3.]]]\n>>> print(output.shape)\n(2, 1, 2)\n>>> input = Tensor(np.ones(shape=[1, 2, 3]), mindspore.float32)\n>>> other = Tensor(np.ones(shape=[1, 3, 2]), mindspore.float32)\n>>> output = ops.dot(input, other)\n>>> print(output)\n[[[[3. 3.]]\n  [[3. 3.]]]]\n>>> print(output.shape)\n(1, 2, 1, 2)\n>>> input = Tensor(np.ones(shape=[1, 2, 3]), mindspore.float32)\n>>> other = Tensor(np.ones(shape=[2, 3, 2]), mindspore.float32)\n>>> output = ops.dot(input, other)\n>>> print(output)\n[[[[3. 3.]\n   [3. 3.]]\n  [[3. 3.]\n   [3. 3.]]]]\n>>> print(output.shape)\n(1, 2, 2, 2)\n>>> input = Tensor(np.ones(shape=[3, 2, 3]), mindspore.float32)\n>>> other = Tensor(np.ones(shape=[2, 1, 3, 2]), mindspore.float32)\n>>> output = ops.dot(input, other)\n>>> print(output)\n[[[[[3. 3.]]\n   [[3. 3.]]]\n  [[[3. 3.]]\n   [[3. 3.]]]]\n [[[[3. 3.]]\n   [[3. 3.]]]\n  [[[3. 3.]]\n   [[3. 3.]]]]\n [[[[3. 3.]]\n   [[3. 3.]]]\n  [[[3. 3.]]\n   [[3. 3.]]]]]\n>>> print(output.shape)\n(3, 2, 2, 1, 2)\n"
  },
  {
    "name": "mindspore.ops.matmul",
    "signature": "mindspore.ops.matmul(input, other)",
    "description": "Returns the matrix product of two tensors.",
    "parameters": [
      "input (Tensor) – Input tensor, scalar not allowed. The last dimension of input must be the same size as the second last dimension of other. And the shape of input and other could be broadcast.",
      "other (Tensor) – Input tensor, scalar not allowed. The last dimension of input must be the same size as the second last dimension of other. And the shape of input and other could be broadcast."
    ],
    "returns": "Tensor or scalar, the matrix product of the inputs. This is a scalar only when both input, other are 1-d vectors.",
    "examples": ">>> import mindspore\n>>> import numpy as np\n>>> from mindspore import Tensor, ops\n>>> # case 1 : Reasonable application of broadcast mechanism\n>>> input = Tensor(np.arange(2*3*4).reshape(2, 3, 4), mindspore.float32)\n>>> other = Tensor(np.arange(4*5).reshape(4, 5), mindspore.float32)\n>>> output = ops.matmul(input, other)\n>>> print(output)\n[[[  70.   76.   82.   88.   94.]\n[ 190.  212.  234.  256.  278.]\n[ 310.  348.  386.  424.  462.]]\n[[ 430.  484.  538.  592.  646.]\n[ 550.  620.  690.  760.  830.]\n[ 670.  756.  842.  928. 1014.]]]\n>>> print(output.shape)\n(2, 3, 5)\n>>> # case 2 : the rank of `input` is 1\n>>> input = Tensor(np.ones([1, 2]), mindspore.float32)\n>>> other = Tensor(np.ones([2,]), mindspore.float32)\n>>> output = ops.matmul(input, other)\n>>> print(output)\n[2.]\n>>> print(output.shape)\n(1,)\n"
  }
]